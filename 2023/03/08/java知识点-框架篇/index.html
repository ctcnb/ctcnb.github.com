<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java知识点——框架篇 | 编程小屋</title><meta name="author" content="阿库娅"><meta name="copyright" content="阿库娅"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Spring refresh 流程要求  掌握 refresh 的 12 个步骤  Spring refresh 概述 refresh 是 AbstractApplicationContext 中的一个方法，负责初始化 ApplicationContext 容器，容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，我们把它们称为 refresh 的 12 个步骤：">
<meta property="og:type" content="article">
<meta property="og:title" content="java知识点——框架篇">
<meta property="og:url" content="http://example.com/2023/03/08/java%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%A1%86%E6%9E%B6%E7%AF%87/index.html">
<meta property="og:site_name" content="编程小屋">
<meta property="og:description" content="1. Spring refresh 流程要求  掌握 refresh 的 12 个步骤  Spring refresh 概述 refresh 是 AbstractApplicationContext 中的一个方法，负责初始化 ApplicationContext 容器，容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，我们把它们称为 refresh 的 12 个步骤：">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-03-08T13:33:25.000Z">
<meta property="article:modified_time" content="2024-07-07T07:41:58.051Z">
<meta property="article:author" content="阿库娅">
<meta property="article:tag" content="java">
<meta property="article:tag" content="spring">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="框架">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/08/java%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%A1%86%E6%9E%B6%E7%AF%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java知识点——框架篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-07 15:41:58'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">78</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="编程小屋"><img class="site-icon" src="https://halo-ctc.upyun.ctcnb.cn/halo/cropped-logo.png"/><span class="site-name">编程小屋</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java知识点——框架篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-03-08T13:33:25.000Z" title="Created 2023-03-08 21:33:25">2023-03-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-07-07T07:41:58.051Z" title="Updated 2024-07-07 15:41:58">2024-07-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java知识点——框架篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-Spring-refresh-流程"><a href="#1-Spring-refresh-流程" class="headerlink" title="1. Spring refresh 流程"></a>1. Spring refresh 流程</h2><p><strong>要求</strong></p>
<ul>
<li>掌握 refresh 的 12 个步骤</li>
</ul>
<p><strong>Spring refresh 概述</strong></p>
<p>refresh 是 AbstractApplicationContext 中的一个方法，负责初始化 ApplicationContext 容器，容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，我们把它们称为 refresh 的 12 个步骤：</p>
<ol>
<li>prepareRefresh</li>
<li>obtainFreshBeanFactory</li>
<li>prepareBeanFactory</li>
<li>postProcessBeanFactory</li>
<li>invokeBeanFactoryPostProcessors</li>
<li>registerBeanPostProcessors</li>
<li>initMessageSource</li>
<li>initApplicationEventMulticaster</li>
<li>onRefresh</li>
<li>registerListeners</li>
<li>finishBeanFactoryInitialization</li>
<li>finishRefresh</li>
</ol>
<blockquote>
<p><strong><em>功能分类</em></strong></p>
<ul>
<li>1 为准备环境</li>
<li>2 3 4 5 6 为准备 BeanFactory</li>
<li>7 8 9 10 12 为准备 ApplicationContext</li>
<li>11 为初始化 BeanFactory 中非延迟单例 bean</li>
</ul>
</blockquote>
<p><strong>1. prepareRefresh</strong></p>
<ul>
<li>这一步创建和准备了 Environment 对象，它作为 ApplicationContext 的一个成员变量</li>
<li>Environment 对象的作用之一是为后续 @Value，值注入时提供键值</li>
<li>Environment 分成三个主要部分</li>
<li>systemProperties - 保存 java 环境键值</li>
<li>systemEnvironment - 保存系统环境键值</li>
<li>自定义 PropertySource - 保存自定义键值，例如来自于 *.properties 文件的键值</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210902181639048.png" alt="image-20210902181639048"></p>
<p><strong>2. obtainFreshBeanFactory</strong></p>
<ul>
<li>这一步获取（或创建） BeanFactory，它也是作为 ApplicationContext 的一个成员变量</li>
<li>BeanFactory 的作用是负责 bean 的创建、依赖注入和初始化，bean 的各项特征由 BeanDefinition 定义</li>
<li>BeanDefinition 作为 bean 的设计蓝图，规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等</li>
<li>BeanDefinition 的来源有多种多样，可以是通过 xml 获得、配置类获得、组件扫描获得，也可以是编程添加</li>
<li>所有的 BeanDefinition 会存入 BeanFactory 中的 beanDefinitionMap 集合</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210902182004819.png" alt="image-20210902182004819"></p>
<p><strong>3. prepareBeanFactory</strong></p>
<ul>
<li>这一步会进一步完善 BeanFactory，为它的各项成员变量赋值</li>
<li>beanExpressionResolver 用来解析 SpEL，常见实现为 StandardBeanExpressionResolver</li>
<li>propertyEditorRegistrars 会注册类型转换器</li>
<li>它在这里使用了 ResourceEditorRegistrar 实现类</li>
<li>并应用 ApplicationContext 提供的 Environment 完成 ${ } 解析</li>
<li>registerResolvableDependency 来注册 beanFactory 以及 ApplicationContext，让它们也能用于依赖注入</li>
<li>beanPostProcessors 是 bean 后处理器集合，会工作在 bean 的生命周期各个阶段，此处会添加两个：</li>
<li>ApplicationContextAwareProcessor 用来解析 Aware 接口</li>
<li>ApplicationListenerDetector 用来识别容器中 ApplicationListener 类型的 bean</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210902182541925.png" alt="image-20210902182541925"></p>
<p><strong>4. postProcessBeanFactory</strong></p>
<ul>
<li>这一步是空实现，留给子类扩展。</li>
<li>一般 Web 环境的 ApplicationContext 都要利用它注册新的 Scope，完善 Web 下的 BeanFactory</li>
<li>这里体现的是模板方法设计模式</li>
</ul>
<p><strong>5. invokeBeanFactoryPostProcessors</strong></p>
<ul>
<li>这一步会调用 beanFactory 后处理器</li>
<li>beanFactory 后处理器，充当 beanFactory 的扩展点，可以用来补充或修改 BeanDefinition</li>
<li>常见的 beanFactory 后处理器有</li>
<li>ConfigurationClassPostProcessor – 解析 @Configuration、@Bean、@Import、@PropertySource 等</li>
<li>PropertySourcesPlaceHolderConfigurer – 替换 BeanDefinition 中的 ${ }</li>
<li>MapperScannerConfigurer – 补充 Mapper 接口对应的 BeanDefinition</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210902183232114.png" alt="image-20210902183232114"></p>
<p><strong>6. registerBeanPostProcessors</strong></p>
<ul>
<li>这一步是继续从 beanFactory 中找出 bean 后处理器，添加至 beanPostProcessors 集合中</li>
<li>bean 后处理器，充当 bean 的扩展点，可以工作在 bean 的实例化、依赖注入、初始化阶段，常见的有：</li>
<li>AutowiredAnnotationBeanPostProcessor 功能有：解析 @Autowired，@Value 注解</li>
<li>CommonAnnotationBeanPostProcessor 功能有：解析 @Resource，@PostConstruct，@PreDestroy</li>
<li>AnnotationAwareAspectJAutoProxyCreator 功能有：为符合切点的目标 bean 自动创建代理</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210902183520307.png" alt="image-20210902183520307"></p>
<p><strong>7. initMessageSource</strong></p>
<ul>
<li>这一步是为 ApplicationContext 添加 messageSource 成员，实现国际化功能</li>
<li>去 beanFactory 内找名为 messageSource 的 bean，如果没有，则提供空的 MessageSource 实现</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210902183819984.png" alt="image-20210902183819984"></p>
<p><strong>8. initApplicationContextEventMulticaster</strong></p>
<ul>
<li>这一步为 ApplicationContext 添加事件广播器成员，即 applicationContextEventMulticaster</li>
<li>它的作用是发布事件给监听器</li>
<li>去 beanFactory 找名为 applicationEventMulticaster 的 bean 作为事件广播器，若没有，会创建默认的事件广播器</li>
<li>之后就可以调用 ApplicationContext.publishEvent(事件对象) 来发布事件</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210902183943469.png" alt="image-20210902183943469"></p>
<p><strong>9. onRefresh</strong></p>
<ul>
<li>这一步是空实现，留给子类扩展</li>
<li>SpringBoot 中的子类在这里准备了 WebServer，即内嵌 web 容器</li>
<li>体现的是模板方法设计模式</li>
</ul>
<p><strong>10. registerListeners</strong></p>
<ul>
<li>这一步会从多种途径找到事件监听器，并添加至 applicationEventMulticaster</li>
<li>事件监听器顾名思义，用来接收事件广播器发布的事件，有如下来源</li>
<li>事先编程添加的</li>
<li>来自容器中的 bean</li>
<li>来自于 @EventListener 的解析</li>
<li>要实现事件监听器，只需要实现 ApplicationListener 接口，重写其中 onApplicationEvent(E e) 方法即可</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210902184343872.png" alt="image-20210902184343872"></p>
<p><strong>11. finishBeanFactoryInitialization</strong></p>
<ul>
<li>这一步会将 beanFactory 的成员补充完毕，并初始化所有非延迟单例 bean</li>
<li>conversionService 也是一套转换机制，作为对 PropertyEditor 的补充</li>
<li>embeddedValueResolvers 即内嵌值解析器，用来解析 @Value 中的 ${ }，借用的是 Environment 的功能</li>
<li>singletonObjects 即单例池，缓存所有单例对象</li>
<li>对象的创建都分三个阶段，每一阶段都有不同的 bean 后处理器参与进来，扩展功能</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210902184641623.png" alt="image-20210902184641623"></p>
<p><strong>12. finishRefresh</strong></p>
<ul>
<li>这一步会为 ApplicationContext 添加 lifecycleProcessor 成员，用来控制容器内需要生命周期管理的 bean</li>
<li>如果容器中有名称为 lifecycleProcessor 的 bean 就用它，否则创建默认的生命周期管理器</li>
<li>准备好生命周期管理器，就可以实现</li>
<li>调用 context 的 start，即可触发所有实现 LifeCycle 接口 bean 的 start</li>
<li>调用 context 的 stop，即可触发所有实现 LifeCycle 接口 bean 的 stop</li>
<li>发布 ContextRefreshed 事件，整个 refresh 执行完成</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210902185052433.png" alt="image-20210902185052433"></p>
<h2 id="2-Spring-bean-生命周期"><a href="#2-Spring-bean-生命周期" class="headerlink" title="2. Spring bean 生命周期"></a>2. Spring bean 生命周期</h2><p><strong>要求</strong></p>
<ul>
<li>掌握 Spring bean 的生命周期</li>
</ul>
<p><strong>bean 生命周期 概述</strong></p>
<p>bean 的生命周期从调用 beanFactory 的 getBean 开始，到这个 bean 被销毁，可以总结为以下七个阶段：</p>
<ol>
<li>处理名称，检查缓存</li>
<li>处理父子容器</li>
<li>处理 dependsOn</li>
<li>选择 scope 策略</li>
<li>创建 bean</li>
<li>类型转换处理</li>
<li>销毁 bean</li>
</ol>
<blockquote>
<p><strong><em>注意</em></strong></p>
<ul>
<li>划分的阶段和名称并不重要，重要的是理解整个过程中做了哪些事情</li>
</ul>
</blockquote>
<p><strong>1. 处理名称，检查缓存</strong></p>
<ul>
<li>这一步会处理别名，将别名解析为实际名称</li>
<li>对 FactoryBean 也会特殊处理，如果以 &amp; 开头表示要获取 FactoryBean 本身，否则表示要获取其产品</li>
<li>这里针对单例对象会检查一级、二级、三级缓存</li>
<li>singletonFactories 三级缓存，存放单例工厂对象</li>
<li>earlySingletonObjects 二级缓存，存放单例工厂的产品对象<ul>
<li>如果发生循环依赖，产品是代理；无循环依赖，产品是原始对象</li>
</ul>
</li>
<li>singletonObjects 一级缓存，存放单例成品对象</li>
</ul>
<p><strong>2. 处理父子容器</strong></p>
<ul>
<li>如果当前容器根据名字找不到这个 bean，此时若父容器存在，则执行父容器的 getBean 流程</li>
<li>父子容器的 bean 名称可以重复</li>
</ul>
<p><strong>3. 处理 dependsOn</strong></p>
<ul>
<li>如果当前 bean 有通过 dependsOn 指定了非显式依赖的 bean，这一步会提前创建这些 dependsOn 的 bean</li>
<li>所谓非显式依赖，就是指两个 bean 之间不存在直接依赖关系，但需要控制它们的创建先后顺序</li>
</ul>
<p><strong>4. 选择 scope 策略</strong></p>
<ul>
<li>对于 singleton scope，首先到单例池去获取 bean，如果有则直接返回，没有再进入创建流程</li>
<li>对于 prototype scope，每次都会进入创建流程</li>
<li>对于自定义 scope，例如 request，首先到 request 域获取 bean，如果有则直接返回，没有再进入创建流程</li>
</ul>
<p><strong>5.1 创建 bean - 创建 bean 实例</strong></p>
<p><strong>要点</strong></p>
<p><strong>总结</strong></p>
<p>有自定义 TargetSource 的情况</p>
<p>由 AnnotationAwareAspectJAutoProxyCreator 创建代理返回</p>
<p>Supplier 方式创建 bean 实例</p>
<p>为 Spring 5.0 新增功能，方便编程方式创建 bean 实例</p>
<p>FactoryMethod 方式 创建 bean 实例</p>
<p>① 分成静态工厂与实例工厂；② 工厂方法若有参数，需要对工厂方法参数进行解析，利用 resolveDependency；③ 如果有多个工厂方法候选者，还要进一步按权重筛选</p>
<p>AutowiredAnnotationBeanPostProcessor</p>
<p>① 优先选择带 @Autowired 注解的构造；② 若有唯一的带参构造，也会入选</p>
<p>mbd.getPreferredConstructors</p>
<p>选择所有公共构造，这些构造之间按权重筛选</p>
<p>采用默认构造</p>
<p>如果上面的后处理器和 BeanDefiniation 都没找到构造，采用默认构造，即使是私有的</p>
<p><strong>5.2 创建 bean - 依赖注入</strong></p>
<p><strong>要点</strong></p>
<p><strong>总结</strong></p>
<p>AutowiredAnnotationBeanPostProcessor</p>
<p>识别 @Autowired 及 @Value 标注的成员，封装为 InjectionMetadata 进行依赖注入</p>
<p>CommonAnnotationBeanPostProcessor</p>
<p>识别 @Resource 标注的成员，封装为 InjectionMetadata 进行依赖注入</p>
<p>resolveDependency</p>
<p>用来查找要装配的值，可以识别：① Optional；② ObjectFactory 及 ObjectProvider；③ @Lazy 注解；④ @Value 注解（${ }, #{ }, 类型转换）；⑤ 集合类型（Collection，Map，数组等）；⑥ 泛型和 @Qualifier（用来区分类型歧义）；⑦ primary 及名字匹配（用来区分类型歧义）</p>
<p>AUTOWIRE_BY_NAME</p>
<p>根据成员名字找 bean 对象，修改 mbd 的 propertyValues，不会考虑简单类型的成员</p>
<p>AUTOWIRE_BY_TYPE</p>
<p>根据成员类型执行 resolveDependency 找到依赖注入的值，修改 mbd 的 propertyValues</p>
<p>applyPropertyValues</p>
<p>根据 mbd 的 propertyValues 进行依赖注入（即xml中 <code>&lt;property name refvalue/&gt;</code>）</p>
<p><strong>5.3 创建 bean - 初始化</strong></p>
<p><strong>要点</strong></p>
<p><strong>总结</strong></p>
<p>内置 Aware 接口的装配</p>
<p>包括 BeanNameAware，BeanFactoryAware 等</p>
<p>扩展 Aware 接口的装配</p>
<p>由 ApplicationContextAwareProcessor 解析，执行时机在 postProcessBeforeInitialization</p>
<p>@PostConstruct</p>
<p>由 CommonAnnotationBeanPostProcessor 解析，执行时机在 postProcessBeforeInitialization</p>
<p>InitializingBean</p>
<p>通过接口回调执行初始化</p>
<p>initMethod</p>
<p>根据 BeanDefinition 得到的初始化方法执行初始化，即 <code>&lt;bean init-method&gt;</code> 或 @Bean(initMethod)</p>
<p>创建 aop 代理</p>
<p>由 AnnotationAwareAspectJAutoProxyCreator 创建，执行时机在 postProcessAfterInitialization</p>
<p><strong>5.4 创建 bean - 注册可销毁 bean</strong></p>
<p>在这一步判断并登记可销毁 bean</p>
<ul>
<li>判断依据</li>
<li>如果实现了 DisposableBean 或 AutoCloseable 接口，则为可销毁 bean</li>
<li>如果自定义了 destroyMethod，则为可销毁 bean</li>
<li>如果采用 @Bean 没有指定 destroyMethod，则采用自动推断方式获取销毁方法名（close，shutdown）</li>
<li>如果有 @PreDestroy 标注的方法</li>
<li>存储位置</li>
<li>singleton scope 的可销毁 bean 会存储于 beanFactory 的成员当中</li>
<li>自定义 scope 的可销毁 bean 会存储于对应的域对象当中</li>
<li>prototype scope 不会存储，需要自己找到此对象销毁</li>
<li>存储时都会封装为 DisposableBeanAdapter 类型对销毁方法的调用进行适配</li>
</ul>
<p><strong>6. 类型转换处理</strong></p>
<ul>
<li>如果 getBean 的 requiredType 参数与实际得到的对象类型不同，会尝试进行类型转换</li>
</ul>
<p><strong>7. 销毁 bean</strong></p>
<ul>
<li>销毁时机</li>
<li>singleton bean 的销毁在 ApplicationContext.close 时，此时会找到所有 DisposableBean 的名字，逐一销毁</li>
<li>自定义 scope bean 的销毁在作用域对象生命周期结束时</li>
<li>prototype bean 的销毁可以通过自己手动调用 AutowireCapableBeanFactory.destroyBean 方法执行销毁</li>
<li>同一 bean 中不同形式销毁方法的调用次序</li>
<li>优先后处理器销毁，即 @PreDestroy</li>
<li>其次 DisposableBean 接口销毁</li>
<li>最后 destroyMethod 销毁（包括自定义名称，推断名称，AutoCloseable 接口 多选一）</li>
</ul>
<h2 id="3-Spring-bean-循环依赖"><a href="#3-Spring-bean-循环依赖" class="headerlink" title="3. Spring bean 循环依赖"></a>3. Spring bean 循环依赖</h2><p><strong>要求</strong></p>
<ul>
<li>掌握单例 set 方式循环依赖的原理</li>
<li>掌握其它循环依赖的解决方法</li>
</ul>
<p><strong>循环依赖的产生</strong></p>
<ul>
<li>首先要明白，bean 的创建要遵循一定的步骤，必须是创建、注入、初始化三步，这些顺序不能乱</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903085238916.png" alt="image-20210903085238916"></p>
<ul>
<li>set 方法（包括成员变量）的循环依赖如图所示</li>
<li>可以在【a 创建】和【a set 注入 b】之间加入 b 的整个流程来解决</li>
<li>【b set 注入 a】 时可以成功，因为之前 a 的实例已经创建完毕</li>
<li>a 的顺序，及 b 的顺序都能得到保障</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903085454603.png" alt="image-20210903085454603"></p>
<ul>
<li>构造方法的循环依赖如图所示，显然无法用前面的方法解决</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903085906315.png" alt="image-20210903085906315"></p>
<p><strong>构造循环依赖的解决</strong></p>
<ul>
<li>思路1</li>
<li>a 注入 b 的代理对象，这样能够保证 a 的流程走通</li>
<li>后续需要用到 b 的真实对象时，可以通过代理间接访问</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903091627659.png" alt="image-20210903091627659"></p>
<ul>
<li>思路2</li>
<li>a 注入 b 的工厂对象，让 b 的实例创建被推迟，这样能够保证 a 的流程先走通</li>
<li>后续需要用到 b 的真实对象时，再通过 ObjectFactory 工厂间接访问</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903091743366.png" alt="image-20210903091743366"></p>
<ul>
<li>示例1：用 @Lazy 为构造方法参数生成代理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class App60_1 &#123;</span><br><span class="line"></span><br><span class="line">    static class A &#123;</span><br><span class="line">        private static final Logger log = LoggerFactory.getLogger(&quot;A&quot;);</span><br><span class="line">        private B b;</span><br><span class="line"></span><br><span class="line">        public A(@Lazy B b) &#123;</span><br><span class="line">            log.debug(&quot;A(B b) &#123;&#125;&quot;, b.getClass());</span><br><span class="line">            this.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @PostConstruct</span><br><span class="line">        public void init() &#123;</span><br><span class="line">            log.debug(&quot;init()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class B &#123;</span><br><span class="line">        private static final Logger log = LoggerFactory.getLogger(&quot;B&quot;);</span><br><span class="line">        private A a;</span><br><span class="line"></span><br><span class="line">        public B(A a) &#123;</span><br><span class="line">            log.debug(&quot;B(&#123;&#125;)&quot;, a);</span><br><span class="line">            this.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @PostConstruct</span><br><span class="line">        public void init() &#123;</span><br><span class="line">            log.debug(&quot;init()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenericApplicationContext context = new GenericApplicationContext();</span><br><span class="line">        context.registerBean(&quot;a&quot;, A.class);</span><br><span class="line">        context.registerBean(&quot;b&quot;, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例2：用 ObjectProvider 延迟依赖对象的创建</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class App60_2 &#123;</span><br><span class="line"></span><br><span class="line">    static class A &#123;</span><br><span class="line">        private static final Logger log = LoggerFactory.getLogger(&quot;A&quot;);</span><br><span class="line">        private ObjectProvider&lt;B&gt; b;</span><br><span class="line"></span><br><span class="line">        public A(ObjectProvider&lt;B&gt; b) &#123;</span><br><span class="line">            log.debug(&quot;A(&#123;&#125;)&quot;, b);</span><br><span class="line">            this.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @PostConstruct</span><br><span class="line">        public void init() &#123;</span><br><span class="line">            log.debug(&quot;init()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class B &#123;</span><br><span class="line">        private static final Logger log = LoggerFactory.getLogger(&quot;B&quot;);</span><br><span class="line">        private A a;</span><br><span class="line"></span><br><span class="line">        public B(A a) &#123;</span><br><span class="line">            log.debug(&quot;B(&#123;&#125;)&quot;, a);</span><br><span class="line">            this.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @PostConstruct</span><br><span class="line">        public void init() &#123;</span><br><span class="line">            log.debug(&quot;init()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenericApplicationContext context = new GenericApplicationContext();</span><br><span class="line">        context.registerBean(&quot;a&quot;, A.class);</span><br><span class="line">        context.registerBean(&quot;b&quot;, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(A.class).b.getObject());</span><br><span class="line">        System.out.println(context.getBean(B.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例3：用 @Scope 产生代理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class App60_3 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenericApplicationContext context = new GenericApplicationContext();</span><br><span class="line">        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(context.getDefaultListableBeanFactory());</span><br><span class="line">        scanner.scan(&quot;com.itheima.app60.sub&quot;);</span><br><span class="line">        context.refresh();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">class A &#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(&quot;A&quot;);</span><br><span class="line">    private B b;</span><br><span class="line"></span><br><span class="line">    public A(B b) &#123;</span><br><span class="line">        log.debug(&quot;A(B b) &#123;&#125;&quot;, b.getClass());</span><br><span class="line">        this.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        log.debug(&quot;init()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br><span class="line">@Component</span><br><span class="line">class B &#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(&quot;B&quot;);</span><br><span class="line">    private A a;</span><br><span class="line"></span><br><span class="line">    public B(A a) &#123;</span><br><span class="line">        log.debug(&quot;B(&#123;&#125;)&quot;, a);</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        log.debug(&quot;init()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例4：用 Provider 接口解决，原理上与 ObjectProvider 一样，Provider 接口是独立的 jar 包，需要加入依赖</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.inject&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class App60_4 &#123;</span><br><span class="line"></span><br><span class="line">    static class A &#123;</span><br><span class="line">        private static final Logger log = LoggerFactory.getLogger(&quot;A&quot;);</span><br><span class="line">        private Provider&lt;B&gt; b;</span><br><span class="line"></span><br><span class="line">        public A(Provider&lt;B&gt; b) &#123;</span><br><span class="line">            log.debug(&quot;A(&#123;&#125;&#125;)&quot;, b);</span><br><span class="line">            this.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @PostConstruct</span><br><span class="line">        public void init() &#123;</span><br><span class="line">            log.debug(&quot;init()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class B &#123;</span><br><span class="line">        private static final Logger log = LoggerFactory.getLogger(&quot;B&quot;);</span><br><span class="line">        private A a;</span><br><span class="line"></span><br><span class="line">        public B(A a) &#123;</span><br><span class="line">            log.debug(&quot;B(&#123;&#125;&#125;)&quot;, a);</span><br><span class="line">            this.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @PostConstruct</span><br><span class="line">        public void init() &#123;</span><br><span class="line">            log.debug(&quot;init()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenericApplicationContext context = new GenericApplicationContext();</span><br><span class="line">        context.registerBean(&quot;a&quot;, A.class);</span><br><span class="line">        context.registerBean(&quot;b&quot;, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(A.class).b.get());</span><br><span class="line">        System.out.println(context.getBean(B.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决-set-循环依赖的原理"><a href="#解决-set-循环依赖的原理" class="headerlink" title="解决 set 循环依赖的原理"></a>解决 set 循环依赖的原理</h3><p><strong>一级缓存</strong></p>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903100752165.png" alt="image-20210903100752165"></p>
<p>作用是保证单例对象仅被创建一次</p>
<ul>
<li>第一次走 <code>getBean(&quot;a&quot;)</code> 流程后，最后会将成品 a 放入 singletonObjects 一级缓存</li>
<li>后续再走 <code>getBean(&quot;a&quot;)</code> 流程时，先从一级缓存中找，这时已经有成品 a，就无需再次创建</li>
</ul>
<p><strong>一级缓存与循环依赖</strong></p>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903100914140.png" alt="image-20210903100914140"></p>
<p>一级缓存无法解决循环依赖问题，分析如下</p>
<ul>
<li>无论是获取 bean a 还是获取 bean b，走的方法都是同一个 getBean 方法，假设先走 <code>getBean(&quot;a&quot;)</code></li>
<li>当 a 的实例对象创建，接下来执行 <code>a.setB()</code> 时，需要走 <code>getBean(&quot;b&quot;)</code> 流程，红色箭头 1</li>
<li>当 b 的实例对象创建，接下来执行 <code>b.setA()</code> 时，又回到了 <code>getBean(&quot;a&quot;)</code> 的流程，红色箭头 2</li>
<li>但此时 singletonObjects 一级缓存内没有成品的 a，陷入了死循环</li>
</ul>
<p><strong>二级缓存</strong></p>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903101849924.png" alt="image-20210903101849924"></p>
<p>解决思路如下：</p>
<ul>
<li>再增加一个 singletonFactories 缓存</li>
<li>在依赖注入前，即 <code>a.setB()</code> 以及 <code>b.setA()</code> 将 a 及 b 的半成品对象（未完成依赖注入和初始化）放入此缓存</li>
<li>执行依赖注入时，先看看 singletonFactories 缓存中是否有半成品的对象，如果有拿来注入，顺利走完流程</li>
</ul>
<p>对于上面的图</p>
<ul>
<li><code>a = new A()</code> 执行之后就会把这个半成品的 a 放入 singletonFactories 缓存，即 <code>factories.put(a)</code></li>
<li>接下来执行 <code>a.setB()</code>，走入 <code>getBean(&quot;b&quot;)</code> 流程，红色箭头 3</li>
<li>这回再执行到 <code>b.setA()</code> 时，需要一个 a 对象，有没有呢？有！</li>
<li><code>factories.get()</code> 在 singletonFactories 缓存中就可以找到，红色箭头 4 和 5</li>
<li>b 的流程能够顺利走完，将 b 成品放入 singletonObject 一级缓存，返回到 a 的依赖注入流程，红色箭头 6</li>
</ul>
<p><strong>二级缓存与创建代理</strong></p>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903103030877.png" alt="image-20210903103030877"></p>
<p>二级缓存无法正确处理循环依赖并且包含有代理创建的场景，分析如下</p>
<ul>
<li>spring 默认要求，在 <code>a.init</code> 完成之后才能创建代理 <code>pa = proxy(a)</code></li>
<li>由于 a 的代理创建时机靠后，在执行 <code>factories.put(a)</code> 向 singletonFactories 中放入的还是原始对象</li>
<li>接下来箭头 3、4、5 这几步 b 对象拿到和注入的都是原始对象</li>
</ul>
<p><strong>三级缓存</strong></p>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903103628639.png" alt="image-20210903103628639"></p>
<p>简单分析的话，只需要将代理的创建时机放在依赖注入之前即可，但 spring 仍然希望代理的创建时机在 init 之后，只有出现循环依赖时，才会将代理的创建时机提前。所以解决思路稍显复杂：</p>
<ul>
<li>图中 <code>factories.put(fa)</code> 放入的既不是原始对象，也不是代理对象而是工厂对象 fa</li>
<li>当检查出发生循环依赖时，fa 的产品就是代理 pa，没有发生循环依赖，fa 的产品是原始对象 a</li>
<li>假设出现了循环依赖，拿到了 singletonFactories 中的工厂对象，通过在依赖注入前获得了 pa，红色箭头 5</li>
<li>这回 <code>b.setA()</code> 注入的就是代理对象，保证了正确性，红色箭头 7</li>
<li>还需要把 pa 存入新加的 earlySingletonObjects 缓存，红色箭头 6</li>
<li><code>a.init</code> 完成后，无需二次创建代理，从哪儿找到 pa 呢？earlySingletonObjects 已经缓存，蓝色箭头 9</li>
</ul>
<p>当成品对象产生，放入 singletonObject 后，singletonFactories 和 earlySingletonObjects 就中的对象就没有用处，清除即可</p>
<h2 id="4-Spring-事务失效"><a href="#4-Spring-事务失效" class="headerlink" title="4. Spring 事务失效"></a>4. Spring 事务失效</h2><p><strong>要求</strong></p>
<ul>
<li>掌握事务失效的八种场景</li>
</ul>
<p><strong>1. 抛出检查异常导致事务不能正确回滚</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Service1 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;</span><br><span class="line">        int fromBalance = accountMapper.findBalanceBy(from);</span><br><span class="line">        if (fromBalance - amount &gt;= 0) &#123;</span><br><span class="line">            accountMapper.update(from, -1 * amount);</span><br><span class="line">            new FileInputStream(&quot;aaa&quot;);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：Spring 默认只会回滚非检查异常</li>
<li>解法：配置 rollbackFor 属性</li>
<li><code>@Transactional(rollbackFor = Exception.class)</code></li>
</ul>
<p><strong>2. 业务方法内自己 try-catch 异常导致事务不能正确回滚</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Service2 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = Exception.class)</span><br><span class="line">    public void transfer(int from, int to, int amount)  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int fromBalance = accountMapper.findBalanceBy(from);</span><br><span class="line">            if (fromBalance - amount &gt;= 0) &#123;</span><br><span class="line">                accountMapper.update(from, -1 * amount);</span><br><span class="line">                new FileInputStream(&quot;aaa&quot;);</span><br><span class="line">                accountMapper.update(to, amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉</li>
<li>解法1：异常原样抛出</li>
<li>在 catch 块添加 <code>throw new RuntimeException(e);</code></li>
<li>解法2：手动设置 TransactionStatus.setRollbackOnly()</li>
<li>在 catch 块添加 <code>TransactionInterceptor.currentTransactionStatus().setRollbackOnly();</code></li>
</ul>
<p><strong>3. aop 切面顺序导致导致事务不能正确回滚</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Service3 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = Exception.class)</span><br><span class="line">    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;</span><br><span class="line">        int fromBalance = accountMapper.findBalanceBy(from);</span><br><span class="line">        if (fromBalance - amount &gt;= 0) &#123;</span><br><span class="line">            accountMapper.update(from, -1 * amount);</span><br><span class="line">            new FileInputStream(&quot;aaa&quot;);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line">    @Around(&quot;execution(* transfer(..))&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">        LoggerUtils.get().debug(&quot;log:&#123;&#125;&quot;, pjp.getTarget());</span><br><span class="line">        try &#123;</span><br><span class="line">            return pjp.proceed();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：事务切面优先级最低，但如果自定义的切面优先级和他一样，则还是自定义切面在内层，这时若自定义切面没有正确抛出异常…</li>
<li>解法1、2：同情况2 中的解法:1、2</li>
<li>解法3：调整切面顺序，在 MyAspect 上添加 <code>@Order(Ordered.LOWEST_PRECEDENCE - 1)</code> （不推荐）</li>
</ul>
<p><strong>4. 非 public 方法导致的事务失效</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Service4 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    void transfer(int from, int to, int amount) throws FileNotFoundException &#123;</span><br><span class="line">        int fromBalance = accountMapper.findBalanceBy(from);</span><br><span class="line">        if (fromBalance - amount &gt;= 0) &#123;</span><br><span class="line">            accountMapper.update(from, -1 * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：Spring 为方法创建代理、添加事务通知、前提条件都是该方法是 public 的</li>
<li>解法1：改为 public 方法</li>
<li>解法2：添加 bean 配置如下（不推荐）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public TransactionAttributeSource transactionAttributeSource() &#123;</span><br><span class="line">    return new AnnotationTransactionAttributeSource(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 父子容器导致的事务失效</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package day04.tx.app.service;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class Service5 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = Exception.class)</span><br><span class="line">    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;</span><br><span class="line">        int fromBalance = accountMapper.findBalanceBy(from);</span><br><span class="line">        if (fromBalance - amount &gt;= 0) &#123;</span><br><span class="line">            accountMapper.update(from, -1 * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制器类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package day04.tx.app.controller;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public Service5 service;</span><br><span class="line"></span><br><span class="line">    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;</span><br><span class="line">        service.transfer(from, to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>App 配置类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;day04.tx.app.service&quot;)</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">// ...</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    // ... 有事务相关配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Web 配置类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;day04.tx.app&quot;)</span><br><span class="line">// ...</span><br><span class="line">public class WebConfig &#123;</span><br><span class="line">    // ... 无事务配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在配置了父子容器，WebConfig 对应子容器，AppConfig 对应父容器，发现事务依然失效</p>
<ul>
<li>原因：子容器扫描范围过大，把未加事务配置的 service 扫描进来</li>
<li>解法1：各扫描各的，不要图简便</li>
<li>解法2：不要用父子容器，所有 bean 放在同一容器</li>
</ul>
<p><strong>6. 调用本类方法导致传播行为失效</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Service6 &#123;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span><br><span class="line">    public void foo() throws FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(&quot;foo&quot;);</span><br><span class="line">        bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span><br><span class="line">    public void bar() throws FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(&quot;bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：本类方法调用不经过代理，因此无法增强</li>
<li>解法1：依赖注入自己（代理）来调用</li>
<li>解法2：通过 AopContext 拿到代理对象，来调用</li>
<li>解法3：通过 CTW，LTW 实现功能增强</li>
</ul>
<p>解法1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Service6 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Service6 proxy; // 本质上是一种循环依赖</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span><br><span class="line">    public void foo() throws FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(&quot;foo&quot;);</span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line">        proxy.bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span><br><span class="line">    public void bar() throws FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(&quot;bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法2，还需要在 AppConfig 上添加 <code>@EnableAspectJAutoProxy(exposeProxy = true)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Service6 &#123;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span><br><span class="line">    public void foo() throws FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(&quot;foo&quot;);</span><br><span class="line">        ((Service6) AopContext.currentProxy()).bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span><br><span class="line">    public void bar() throws FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(&quot;bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7. @Transactional 没有保证原子行为</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Service7 &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(Service7.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = Exception.class)</span><br><span class="line">    public void transfer(int from, int to, int amount) &#123;</span><br><span class="line">        int fromBalance = accountMapper.findBalanceBy(from);</span><br><span class="line">        logger.debug(&quot;更新前查询余额为: &#123;&#125;&quot;, fromBalance);</span><br><span class="line">        if (fromBalance - amount &gt;= 0) &#123;</span><br><span class="line">            accountMapper.update(from, -1 * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int findBalance(int accountNo) &#123;</span><br><span class="line">        return accountMapper.findBalanceBy(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实际上是有 bug 的，假设 from 余额为 1000，两个线程都来转账 1000，可能会出现扣减为负数的情况</p>
<ul>
<li>原因：事务的原子性仅涵盖 insert、update、delete、select … for update 语句，select 方法并不阻塞</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903120436365.png" alt="image-20210903120436365"></p>
<ul>
<li>如上图所示，红色线程和蓝色线程的查询都发生在扣减之前，都以为自己有足够的余额做扣减</li>
</ul>
<p><strong>8. @Transactional 方法导致的 synchronized 失效</strong></p>
<p>针对上面的问题，能否在方法上加 synchronized 锁来解决呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Service7 &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(Service7.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = Exception.class)</span><br><span class="line">    public synchronized void transfer(int from, int to, int amount) &#123;</span><br><span class="line">        int fromBalance = accountMapper.findBalanceBy(from);</span><br><span class="line">        logger.debug(&quot;更新前查询余额为: &#123;&#125;&quot;, fromBalance);</span><br><span class="line">        if (fromBalance - amount &gt;= 0) &#123;</span><br><span class="line">            accountMapper.update(from, -1 * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int findBalance(int accountNo) &#123;</span><br><span class="line">        return accountMapper.findBalanceBy(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是不行，原因如下：</p>
<ul>
<li>synchronized 保证的仅是目标方法的原子性，环绕目标方法的还有 commit 等操作，它们并未处于 sync 块内</li>
<li>可以参考下图发现，蓝色线程的查询只要在红色线程提交之前执行，那么依然会查询到有 1000 足够余额来转账</li>
</ul>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903120800185.png" alt="image-20210903120800185"></p>
<ul>
<li>解法1：synchronized 范围应扩大至代理方法调用</li>
<li>解法2：使用 select … for update 替换 select</li>
</ul>
<h2 id="5-Spring-MVC-执行流程"><a href="#5-Spring-MVC-执行流程" class="headerlink" title="5. Spring MVC 执行流程"></a>5. Spring MVC 执行流程</h2><p><strong>要求</strong></p>
<ul>
<li>掌握 Spring MVC 的执行流程</li>
<li>了解 Spring MVC 的重要组件的作用</li>
</ul>
<p><strong>概要</strong></p>
<p>我把整个流程分成三个阶段</p>
<ul>
<li>准备阶段</li>
<li>匹配阶段</li>
<li>执行阶段</li>
</ul>
<p><strong>准备阶段</strong></p>
<ol>
<li>在 Web 容器第一次用到 DispatcherServlet 的时候，会创建其对象并执行 init 方法</li>
<li>init 方法内会创建 Spring Web 容器，并调用容器 refresh 方法</li>
<li>refresh 过程中会创建并初始化 SpringMVC 中的重要组件， 例如 MultipartResolver，HandlerMapping，HandlerAdapter，HandlerExceptionResolver、ViewResolver 等</li>
<li>容器初始化后，会将上一步初始化好的重要组件，赋值给 DispatcherServlet 的成员变量，留待后用</li>
</ol>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903140657163.png" alt="image-20210903140657163"></p>
<p><strong>匹配阶段</strong></p>
<ol>
<li>用户发送的请求统一到达前端控制器 DispatcherServlet</li>
<li>DispatcherServlet 遍历所有 HandlerMapping ，找到与路径匹配的处理器 ① HandlerMapping 有多个，每个 HandlerMapping 会返回不同的处理器对象，谁先匹配，返回谁的处理器。其中能识别 @RequestMapping 的优先级最高 ② 对应 @RequestMapping 的处理器是 HandlerMethod，它包含了控制器对象和控制器方法信息 ③ 其中路径与处理器的映射关系在 HandlerMapping 初始化时就会建立好</li>
</ol>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903141017502.png" alt="image-20210903141017502"></p>
<ol start="3">
<li>将 HandlerMethod 连同匹配到的拦截器，生成调用链对象 HandlerExecutionChain 返回</li>
</ol>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903141124911.png" alt="image-20210903141124911"></p>
<ol start="4">
<li>遍历HandlerAdapter 处理器适配器，找到能处理 HandlerMethod 的适配器对象，开始调用</li>
</ol>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903141204799.png" alt="image-20210903141204799"></p>
<p><strong>调用阶段</strong></p>
<ol>
<li>执行拦截器 preHandle</li>
</ol>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903141445870.png" alt="image-20210903141445870"></p>
<ol start="2">
<li>由 HandlerAdapter 调用 HandlerMethod ① 调用前处理不同类型的参数 ② 调用后处理不同类型的返回值</li>
</ol>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903141658199.png" alt="image-20210903141658199"></p>
<ol start="3">
<li>第 2 步没有异常 ① 返回 ModelAndView ② 执行拦截器 postHandle 方法 ③ 解析视图，得到 View 对象，进行视图渲染</li>
</ol>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903141749830.png" alt="image-20210903141749830"></p>
<ol start="4">
<li>第 2 步有异常，进入 HandlerExceptionResolver 异常处理流程</li>
</ol>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20210903141844185.png" alt="image-20210903141844185"></p>
<ol start="5">
<li>最后都会执行拦截器的 afterCompletion 方法</li>
<li>如果控制器方法标注了 @ResponseBody 注解，则在第 2 步，就会生成 json 结果，并标记 ModelAndView 已处理，这样就不会执行第 3 步的视图渲染</li>
</ol>
<h2 id="6-Spring-注解"><a href="#6-Spring-注解" class="headerlink" title="6. Spring 注解"></a>6. Spring 注解</h2><p><strong>要求</strong></p>
<ul>
<li>掌握 Spring 常见注解</li>
</ul>
<blockquote>
<p><strong><em>提示</em></strong></p>
<ul>
<li>注解的详细列表请参考：面试题-spring-注解.xmind</li>
<li>下面列出了视频中重点提及的注解，考虑到大部分注解同学们已经比较熟悉了，仅对个别的作简要说明</li>
</ul>
</blockquote>
<p><strong>事务注解</strong></p>
<ul>
<li>@EnableTransactionManagement，会额外加载 4 个 bean</li>
<li>BeanFactoryTransactionAttributeSourceAdvisor 事务切面类</li>
<li>TransactionAttributeSource 用来解析事务属性</li>
<li>TransactionInterceptor 事务拦截器</li>
<li>TransactionalEventListenerFactory 事务监听器工厂</li>
<li>@Transactional</li>
</ul>
<p><strong>核心</strong></p>
<ul>
<li>@Order</li>
</ul>
<p><strong>切面</strong></p>
<ul>
<li>@EnableAspectJAutoProxy</li>
<li>会加载 AnnotationAwareAspectJAutoProxyCreator，它是一个 bean 后处理器，用来创建代理</li>
<li>如果没有配置 @EnableAspectJAutoProxy，又需要用到代理（如事务）则会使用 InfrastructureAdvisorAutoProxyCreator 这个 bean 后处理器</li>
</ul>
<p><strong>组件扫描与配置类</strong></p>
<ul>
<li>@Component</li>
<li>@Controller</li>
<li>@Service</li>
<li>@Repository</li>
<li>@ComponentScan</li>
<li>@Conditional</li>
<li>@Configuration</li>
<li>配置类其实相当于一个工厂, 标注 @Bean 注解的方法相当于工厂方法</li>
<li>@Bean 不支持方法重载, 如果有多个重载方法, 仅有一个能入选为工厂方法</li>
<li>@Configuration 默认会为标注的类生成代理, 其目的是保证 @Bean 方法相互调用时, 仍然能保证其单例特性</li>
<li>@Configuration 中如果含有 BeanFactory 后处理器, 则实例工厂方法会导致 MyConfig 提前创建, 造成其依赖注入失败，解决方法是改用静态工厂方法或直接为 @Bean 的方法参数依赖注入, 针对 Mapper 扫描可以改用注解方式</li>
<li>@Bean</li>
<li>@Import</li>
<li>四种用法 ① 引入单个 bean ② 引入一个配置类 ③ 通过 Selector 引入多个类 ④ 通过 beanDefinition 注册器</li>
<li>解析规则<ul>
<li>同一配置类中, @Import 先解析 @Bean 后解析</li>
<li>同名定义, 默认后面解析的会覆盖前面解析的</li>
<li>不允许覆盖的情况下, 如何能够让 MyConfig(主配置类) 的配置优先? (虽然覆盖方式能解决)</li>
<li>采用 DeferredImportSelector，因为它最后工作, 可以简单认为先解析 @Bean, 再 Import</li>
</ul>
</li>
<li>@Lazy</li>
<li>加在类上，表示此类延迟实例化、初始化</li>
<li>加在方法参数上，此参数会以代理方式注入</li>
<li>@PropertySource</li>
</ul>
<p><strong>依赖注入</strong></p>
<ul>
<li>@Autowired</li>
<li>@Qualifier</li>
<li>@Value</li>
</ul>
<p><strong>mvc mapping</strong></p>
<ul>
<li>@RequestMapping，可以派生多个注解如 @GetMapping 等</li>
</ul>
<p><strong>mvc rest</strong></p>
<ul>
<li>@RequestBody</li>
<li>@ResponseBody，组合 @Controller &#x3D;&gt; @RestController</li>
<li>@ResponseStatus</li>
</ul>
<p><strong>mvc 统一处理</strong></p>
<ul>
<li>@ControllerAdvice，组合 @ResponseBody &#x3D;&gt; @RestControllerAdvice</li>
<li>@ExceptionHandler</li>
</ul>
<p><strong>mvc 参数</strong></p>
<ul>
<li>@PathVariable</li>
</ul>
<p><strong>mvc ajax</strong></p>
<ul>
<li>@CrossOrigin</li>
</ul>
<p><strong>boot auto</strong></p>
<ul>
<li>@SpringBootApplication</li>
<li>@EnableAutoConfiguration</li>
<li>@SpringBootConfiguration</li>
</ul>
<p><strong>boot condition</strong></p>
<ul>
<li>@ConditionalOnClass，classpath 下存在某个 class 时，条件才成立</li>
<li>@ConditionalOnMissingBean，beanFactory 内不存在某个 bean 时，条件才成立</li>
<li>@ConditionalOnProperty，配置文件中存在某个 property（键、值）时，条件才成立</li>
</ul>
<p><strong>boot properties</strong></p>
<ul>
<li>@ConfigurationProperties，会将当前 bean 的属性与配置文件中的键值进行绑定</li>
<li>@EnableConfigurationProperties，会添加两个较为重要的 bean</li>
<li>ConfigurationPropertiesBindingPostProcessor，bean 后处理器，在 bean 初始化前调用下面的 binder</li>
<li>ConfigurationPropertiesBinder，真正执行绑定操作</li>
</ul>
<h2 id="7-SpringBoot-自动配置原理"><a href="#7-SpringBoot-自动配置原理" class="headerlink" title="7. SpringBoot 自动配置原理"></a>7. SpringBoot 自动配置原理</h2><p><strong>要求</strong></p>
<ul>
<li>掌握 SpringBoot 自动配置原理</li>
</ul>
<p><strong>自动配置原理</strong></p>
<p>@SpringBootConfiguration 是一个组合注解，由 @ComponentScan、@EnableAutoConfiguration 和 @SpringBootConfiguration 组成</p>
<ol>
<li>@SpringBootConfiguration 与普通 @Configuration 相比，唯一区别是前者要求整个 app 中只出现一次</li>
<li>@ComponentScan</li>
</ol>
<ul>
<li>excludeFilters - 用来在组件扫描时进行排除，也会排除自动配置类</li>
</ul>
<ol>
<li>@EnableAutoConfiguration 也是一个组合注解，由下面注解组成</li>
</ol>
<ul>
<li>@AutoConfigurationPackage – 用来记住扫描的起始包</li>
<li>@Import(AutoConfigurationImportSelector.class) 用来加载 <code>META-INF/spring.factories</code> 中的自动配置类</li>
</ul>
<p><strong>为什么不使用 @Import 直接引入自动配置类</strong></p>
<p>有两个原因：</p>
<ol>
<li>让主配置类和自动配置类变成了强耦合，主配置类不应该知道有哪些从属配置</li>
<li>直接用 <code>@Import(自动配置类.class)</code>，引入的配置解析优先级较高，自动配置类的解析应该在主配置没提供时作为默认配置</li>
</ol>
<p>因此，采用了 <code>@Import(AutoConfigurationImportSelector.class)</code></p>
<ul>
<li>由 <code>AutoConfigurationImportSelector.class</code> 去读取 <code>META-INF/spring.factories</code> 中的自动配置类，实现了弱耦合。</li>
<li>另外 <code>AutoConfigurationImportSelector.class</code> 实现了 DeferredImportSelector 接口，让自动配置的解析晚于主配置的解析</li>
</ul>
<h2 id="8-Spring-中的设计模式"><a href="#8-Spring-中的设计模式" class="headerlink" title="8. Spring 中的设计模式"></a>8. Spring 中的设计模式</h2><p><strong>要求</strong></p>
<ul>
<li>掌握 Spring 中常见的设计模式</li>
</ul>
<p><strong>1. Spring 中的 Singleton</strong></p>
<p>请大家区分 singleton pattern 与 Spring 中的 singleton bean</p>
<ul>
<li>根据单例模式的目的 <em>Ensure a class only has one instance, and provide a global point of access to it</em></li>
<li>显然 Spring 中的 singleton bean 并非实现了单例模式，singleton bean 只能保证每个容器内，相同 id 的 bean 单实例</li>
<li>当然 Spring 中也用到了单例模式，例如</li>
<li>org.springframework.transaction.TransactionDefinition#withDefaults</li>
<li>org.springframework.aop.TruePointcut#INSTANCE</li>
<li>org.springframework.aop.interceptor.ExposeInvocationInterceptor#ADVISOR</li>
<li>org.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE</li>
<li>org.springframework.core.OrderComparator#INSTANCE</li>
</ul>
<p><strong>2. Spring 中的 Builder</strong></p>
<p>定义 <em>Separate the construction of a complex object from its representation so that the same construction process can create different representations</em></p>
<p>它的主要亮点有三处：</p>
<ol>
<li>较为灵活的构建产品对象</li>
<li>在不执行最后 build 方法前，产品对象都不可用</li>
<li>构建过程采用链式调用，看起来比较爽</li>
</ol>
<p>Spring 中体现 Builder 模式的地方：</p>
<ul>
<li>org.springframework.beans.factory.support.BeanDefinitionBuilder</li>
<li>org.springframework.web.util.UriComponentsBuilder</li>
<li>org.springframework.http.ResponseEntity.HeadersBuilder</li>
<li>org.springframework.http.ResponseEntity.BodyBuilder</li>
</ul>
<p><strong>3. Spring 中的 Factory Method</strong></p>
<p>定义 <em>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses</em></p>
<p>根据上面的定义，Spring 中的 ApplicationContext 与 BeanFactory 中的 getBean 都可以视为工厂方法，它隐藏了 bean （产品）的创建过程和具体实现</p>
<p>Spring 中其它工厂：</p>
<ul>
<li>org.springframework.beans.factory.FactoryBean</li>
<li>@Bean 标注的静态方法及实例方法</li>
<li>ObjectFactory 及 ObjectProvider</li>
</ul>
<p>前两种工厂主要封装第三方的 bean 的创建过程，后两种工厂可以推迟 bean 创建，解决循环依赖及单例注入多例等问题</p>
<p><strong>4. Spring 中的 Adapter</strong></p>
<p>定义 <em>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces</em></p>
<p>典型的实现有两处：</p>
<ul>
<li>org.springframework.web.servlet.HandlerAdapter – 因为控制器实现有各种各样，比如有</li>
<li>大家熟悉的 @RequestMapping 标注的控制器实现</li>
<li>传统的基于 Controller 接口（不是 @Controller注解啊）的实现</li>
<li>较新的基于 RouterFunction 接口的实现</li>
<li>它们的处理方法都不一样，为了统一调用，必须适配为 HandlerAdapter 接口</li>
<li>org.springframework.beans.factory.support.DisposableBeanAdapter – 因为销毁方法多种多样，因此都要适配为 DisposableBean 来统一调用销毁方法</li>
</ul>
<p><strong>5. Spring 中的 Composite</strong></p>
<p>定义 <em>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly</em></p>
<p>典型实现有：</p>
<ul>
<li>org.springframework.web.method.support.HandlerMethodArgumentResolverComposite</li>
<li>org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite</li>
<li>org.springframework.web.servlet.handler.HandlerExceptionResolverComposite</li>
<li>org.springframework.web.servlet.view.ViewResolverComposite</li>
</ul>
<p>composite 对象的作用是，将分散的调用集中起来，统一调用入口，它的特征是，与具体干活的实现实现同一个接口，当调用 composite 对象的接口方法时，其实是委托具体干活的实现来完成</p>
<p><strong>6. Spring 中的 Decorator</strong></p>
<p>定义 <em>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality</em></p>
<p>典型实现：</p>
<ul>
<li>org.springframework.web.util.ContentCachingRequestWrapper</li>
</ul>
<p><strong>7. Spring 中的 Proxy</strong></p>
<p>定义 <em>Provide a surrogate or placeholder for another object to control access to it</em></p>
<p>装饰器模式注重的是功能增强，避免子类继承方式进行功能扩展，而代理模式更注重控制目标的访问</p>
<p>典型实现：</p>
<ul>
<li>org.springframework.aop.framework.JdkDynamicAopProxy</li>
<li>org.springframework.aop.framework.ObjenesisCglibAopProxy</li>
</ul>
<p><strong>8. Spring 中的 Chain of Responsibility</strong></p>
<p>定义 <em>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it</em></p>
<p>典型实现：</p>
<ul>
<li>org.springframework.web.servlet.HandlerInterceptor</li>
</ul>
<p><strong>9. Spring 中的 Observer</strong></p>
<p>定义 <em>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically</em></p>
<p>典型实现：</p>
<ul>
<li>org.springframework.context.ApplicationListener</li>
<li>org.springframework.context.event.ApplicationEventMulticaster</li>
<li>org.springframework.context.ApplicationEvent</li>
</ul>
<p><strong>10. Spring 中的 Strategy</strong></p>
<p>定义 <em>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it</em></p>
<p>典型实现：</p>
<ul>
<li>org.springframework.beans.factory.support.InstantiationStrategy</li>
<li>org.springframework.core.annotation.MergedAnnotations.SearchStrategy</li>
<li>org.springframework.boot.autoconfigure.condition.SearchStrategy</li>
</ul>
<p><strong>11. Spring 中的 Template Method</strong></p>
<p>定义 <em>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure</em></p>
<p>典型实现：</p>
<ul>
<li>大部分以 Template 命名的类，如 JdbcTemplate，TransactionTemplate</li>
<li>很多以 Abstract 命名的类，如 AbstractApplicationContext</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">阿库娅</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/08/java%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%A1%86%E6%9E%B6%E7%AF%87/">http://example.com/2023/03/08/java%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%A1%86%E6%9E%B6%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/spring/">spring</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/12/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/" title="使用docker部署springboot项目"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">使用docker部署springboot项目</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/08/java%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87/" title="java知识点——虚拟机篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">java知识点——虚拟机篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/11/25/java%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%B9%B6%E5%8F%91%E7%AF%87/" title="java知识点-并发篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="title">java知识点-并发篇</div></div></a></div><div><a href="/2023/03/08/java%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87/" title="java知识点——虚拟机篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">java知识点——虚拟机篇</div></div></a></div><div><a href="/2023/05/12/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/" title="使用docker部署springboot项目"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-12</div><div class="title">使用docker部署springboot项目</div></div></a></div><div><a href="/2023/02/12/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/" title="压力测试和JMeter的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">压力测试和JMeter的使用</div></div></a></div><div><a href="/2022/11/15/java%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%9F%BA%E7%A1%80%E7%AF%87/" title="java知识点-基础篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-15</div><div class="title">java知识点-基础篇</div></div></a></div><div><a href="/2023/01/14/sentinel%E5%AE%9E%E7%8E%B0%E7%86%94%E6%96%AD+%E9%99%8D%E7%BA%A7+%E9%99%90%E6%B5%81/" title="sentinel实现熔断+降级+限流"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-14</div><div class="title">sentinel实现熔断+降级+限流</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">阿库娅</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">78</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ctcnb"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Spring-refresh-%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">1. Spring refresh 流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Spring-bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.</span> <span class="toc-text">2. Spring bean 生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Spring-bean-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">3.</span> <span class="toc-text">3. Spring bean 循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-set-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">解决 set 循环依赖的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Spring-%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="toc-number">4.</span> <span class="toc-text">4. Spring 事务失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Spring-MVC-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">5. Spring MVC 执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Spring-%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">6. Spring 注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-SpringBoot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">7. SpringBoot 自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Spring-%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">8. Spring 中的设计模式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/07/%E5%9C%A8%E7%BB%BF%E8%81%94%E4%B8%8A%E5%AE%89%E8%A3%85clouddrive2/" title="在绿联上安装clouddrive2">在绿联上安装clouddrive2</a><time datetime="2024-07-07T02:22:00.000Z" title="Created 2024-07-07 10:22:00">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/07/%E4%BD%BF%E7%94%A8github%E5%92%8Ccloudflare%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%BB%BAdocker%E5%8A%A0%E9%80%9F%E5%99%A8%EF%BC%8C%E8%A7%A3%E5%86%B3docker%E9%95%9C%E5%83%8F%E6%97%A0%E6%B3%95%E6%8B%89%E5%8F%96/" title="使用github和cloudflare实现自建docker加速器，解决docker镜像无法拉取的问题">使用github和cloudflare实现自建docker加速器，解决docker镜像无法拉取的问题</a><time datetime="2024-07-07T02:20:36.000Z" title="Created 2024-07-07 10:20:36">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/07/docker-java%E4%BD%BF%E7%94%A8win%E7%B3%BB%E7%BB%9F%E4%B8%8Bdocker/" title="docker-java使用win系统下docker">docker-java使用win系统下docker</a><time datetime="2024-07-07T02:18:45.000Z" title="Created 2024-07-07 10:18:45">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/07/api%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/" title="api开发平台">api开发平台</a><time datetime="2024-07-07T02:16:44.000Z" title="Created 2024-07-07 10:16:44">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/07/python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E4%B8%BAwin-linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/" title="python程序打包为win/linux可执行文件">python程序打包为win/linux可执行文件</a><time datetime="2024-07-07T01:47:49.000Z" title="Created 2024-07-07 09:47:49">2024-07-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 阿库娅</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>