<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>分类: 文档 | 编程小屋</title><meta name="author" content="阿库娅"><meta name="copyright" content="阿库娅"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、概念1.总结1.调用方设置controller资源限流，会返回UrlBlockSentinelHandler处理信息（当前流量请求过大）【url资源】2.调用方设置feign资源降级，会触发熔断fallback3.被调用方宕机，会触发熔断fallback4.提供方设置controller资源降级，会触发UrlBlockSentinelHandler处理信息（当前流量请求过大）【url资源】5.">
<meta property="og:type" content="article">
<meta property="og:title" content="sentinel实现熔断+降级+限流">
<meta property="og:url" content="http://020327.xyz/2023/01/7bc9b569e5a0.html">
<meta property="og:site_name" content="编程小屋">
<meta property="og:description" content="一、概念1.总结1.调用方设置controller资源限流，会返回UrlBlockSentinelHandler处理信息（当前流量请求过大）【url资源】2.调用方设置feign资源降级，会触发熔断fallback3.被调用方宕机，会触发熔断fallback4.提供方设置controller资源降级，会触发UrlBlockSentinelHandler处理信息（当前流量请求过大）【url资源】5.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://common.ctcnb.cn/avatar.png">
<meta property="article:published_time" content="2023-01-14T13:12:56.000Z">
<meta property="article:modified_time" content="2024-07-07T09:11:04.647Z">
<meta property="article:author" content="阿库娅">
<meta property="article:tag" content="java">
<meta property="article:tag" content="spring">
<meta property="article:tag" content="alibaba">
<meta property="article:tag" content="springcloud">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://common.ctcnb.cn/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://020327.xyz/2023/01/7bc9b569e5a0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分类: 文档',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-07 17:11:04'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://common.ctcnb.cn/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="编程小屋"><img class="site-icon" src="https://halo-ctc.upyun.ctcnb.cn/halo/cropped-logo.png"/><span class="site-name">编程小屋</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">sentinel实现熔断+降级+限流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-14T13:12:56.000Z" title="发表于 2023-01-14 21:12:56">2023-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-07T09:11:04.647Z" title="更新于 2024-07-07 17:11:04">2024-07-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%96%87%E6%A1%A3/">文档</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="sentinel实现熔断+降级+限流"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h2><p>1.调用方设置controller资源<strong>限流</strong>，会返回UrlBlockSentinelHandler处理信息（当前流量请求过大）【url资源】<br>2.调用方设置feign资源<strong>降级</strong>，会触发熔断fallback<br>3.被调用方<strong>宕机</strong>，会触发熔断fallback<br>4.提供方设置controller资源<strong>降级</strong>，会触发UrlBlockSentinelHandler处理信息（当前流量请求过大）【url资源】<br>5.自定义资源<strong>限流</strong>，会执行catch【当资源时一段代码时，使用自定义资源try catch】<br>6.注解方式定义资源<strong>限流</strong>，会触发指定blockHandler【当资源时方法时使用注解】</p>
<p>url资源统一使用UrlBlockSentinelHandler处理，自定义资源、注解资源需要单独处理（blockHandler和catch）</p>
<h2 id="2-熔断"><a href="#2-熔断" class="headerlink" title="2.熔断"></a>2.熔断</h2><blockquote>
<p>什么是熔断？<br>A服务调用B服务的某个功能,由于网络不稳定问题，或者B服务卡机，导致功能时间超长。如果这样子的次数太多。我们就可以直接将B断路了(A不再请求B接口），凡是调用B的直接返回降级数据，不必等待B的超长执行。这样B的故障问题，就不会级联影响到A。（是调用方的主动规则）</p>
<p>一句话解释：不可用的资源请求、和降级的资源请求会触发熔断，执行fallback（不用等待超时异常直接返回）</p>
</blockquote>
<h2 id="3-降级"><a href="#3-降级" class="headerlink" title="3.降级"></a>3.降级</h2><blockquote>
<p>什么是降级？<br>整个网站处于流量高峰期，服务器压力剧增，根据当前业务情况及流量，对一些服务和页面进行有策略的降级[停止服务，所有的调用直接返回降级数据]。以此缓解服务器资源的的压力，以保证核心业务的正常运行，同时也保持了客户和大部分客户的得到正确的相应。（也是调用方的主动设置）</p>
<p>一句话解释：符合降级规则的资源请求，在接下来的窗口期都会触发熔断，而不会请求资源</p>
</blockquote>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/gulimall-dev/1641569789240.png" alt="1641569789240"></p>
<p>1**.宕机的feign请求**会触发熔断fallback</p>
<p>2.<strong>调用方设置feign请求降级规则</strong>，降级后触发熔断fallback</p>
<p>3.<strong>调用方不设置feign降级，而提供方设置controller资源降级</strong>，降级后触发提供方的限流handle处理（UrlBlockSentinelHandler）一般用作高并发场景下让出资源</p>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/gulimall-dev/1641570662185.png" alt="1641570662185"></p>
<h2 id="4-熔断与降级异同点"><a href="#4-熔断与降级异同点" class="headerlink" title="4.熔断与降级异同点"></a>4.熔断与降级异同点</h2><blockquote>
<p>相同点:<br>1、为了保证集群大部分服务的可用性和可靠性，防止崩溃，牺牲小我2、用户最终都是体验到某个功能不可用</p>
<p>不同点:<br>1、熔断是被调用方故障，调用方主动触发<br>2、降级是基于全局考虑，停止部分资源调用，触发熔断快速返回</p>
</blockquote>
<h2 id="5-限流"><a href="#5-限流" class="headerlink" title="5.限流"></a>5.限流</h2><blockquote>
<p>什么是限流？【一定要实现限流】<br>对打入服务的请求流量进行控制，使服务能够承担不超过自己能力的流量压力【丢弃超出的请求】</p>
</blockquote>
<h1 id="二、实现方案"><a href="#二、实现方案" class="headerlink" title="二、实现方案"></a>二、实现方案</h1><h2 id="1-Hystrix"><a href="#1-Hystrix" class="headerlink" title="1.Hystrix"></a>1.Hystrix</h2><blockquote>
<p>注：已经不更新了</p>
</blockquote>
<ul>
<li>隔离策略：线程池；为每一个请求新增一个线程池，每个请求过来分配一个线程（资源大、性能低）</li>
<li>熔断降级策略：基于异常比例；</li>
<li>实时统计实现：滑动窗口</li>
<li>动态规则配置：支持多种数据源（之前的配置需要持久化）</li>
<li>扩展性：插件形式</li>
<li>基于注解的支持：支持</li>
<li>限流：有限的支持</li>
<li>流量整形：不支持</li>
<li>系统自适应保护：不支持；系统判断当前是否处于高峰期，判断是否放行请求</li>
<li>控制台：简单的监控查看</li>
</ul>
<h2 id="2-Sentinel"><a href="#2-Sentinel" class="headerlink" title="2.Sentinel"></a>2.Sentinel</h2><blockquote>
<p>springcloud alibaba</p>
</blockquote>
<h2 id="3-Hystrix、Sentinel对比图"><a href="#3-Hystrix、Sentinel对比图" class="headerlink" title="3.Hystrix、Sentinel对比图"></a>3.Hystrix、Sentinel对比图</h2><p><img src="https://halo-ctc.upyun.ctcnb.cn/gulimall-dev/1641529294035.png" alt="1641529294035"></p>
<h1 id="三、Sentinel"><a href="#三、Sentinel" class="headerlink" title="三、Sentinel"></a>三、Sentinel</h1><h2 id="1-文档"><a href="#1-文档" class="headerlink" title="1.文档"></a>1.文档</h2><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/">介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E7%9A%84%E9%80%82%E9%85%8D">主流框架适配</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E7%9A%84%E9%80%82%E9%85%8D#spring-cloud">适配spring-cloud</a><br><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel">适配spring-cloud详细步骤</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E7%9A%84%E9%80%82%E9%85%8D#feign">适配feign</a><br><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel">适配feign详细步骤</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases">控制台下载</a></p>
<h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h2><blockquote>
<p>Sentinel 可以简单的分为 Sentinel 核心库和 Dashboard。核心库不依赖 Dashboard，但是结合 Dashboard 可以取得最好的效果。</p>
</blockquote>
<h2 id="3-使用步骤"><a href="#3-使用步骤" class="headerlink" title="3.使用步骤"></a>3.使用步骤</h2><p>使用 Sentinel 来进行资源保护，主要分为几个步骤:</p>
<ol>
<li>定义资源</li>
<li>定义规则</li>
<li>检验规则是否生效</li>
</ol>
<h3 id="3-1-定义资源"><a href="#3-1-定义资源" class="headerlink" title="3.1.定义资源"></a>3.1.定义资源</h3><blockquote>
<p>注意：<br>资源需要定义，例如使用注解定义资源<br>但是springboot默认给所以方法设置成了资源，所以可以省略</p>
</blockquote>
<h4 id="方式一：主流框架的默认适配"><a href="#方式一：主流框架的默认适配" class="headerlink" title="方式一：主流框架的默认适配"></a>方式一：主流框架的默认适配</h4><blockquote>
<p>主流的框架默认配置成了资源，例如所有controller的api，feign的Api</p>
</blockquote>
<p>为了减少开发的复杂程度，我们对大部分的主流框架，例如 Web Servlet、Dubbo、Spring Cloud、gRPC、Spring WebFlux、Reactor 等都做了适配。您只需要引入对应的依赖即可方便地整合 Sentinel。可以参见: <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E7%9A%84%E9%80%82%E9%85%8D">主流框架的适配</a>。</p>
<h4 id="方式二：抛出异常的方式定义资源"><a href="#方式二：抛出异常的方式定义资源" class="headerlink" title="方式二：抛出异常的方式定义资源"></a>方式二：抛出异常的方式定义资源</h4><p><code>SphU</code> 包含了 try-catch 风格的 API。用这种方式，当资源发生了限流之后会抛出 <code>BlockException</code>。这个时候可以捕捉异常，进行限流之后的逻辑处理。示例代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1.5.0 版本开始可以利用 try-with-resources 特性（使用有限制）</span><br><span class="line">// 资源名可使用任意有业务语义的字符串，比如方法名、接口名或其它可唯一标识的字符串。</span><br><span class="line">try (Entry entry = SphU.entry(&quot;resourceName&quot;)) &#123;</span><br><span class="line">  // 被保护的业务逻辑</span><br><span class="line">  // do something here...</span><br><span class="line">&#125; catch (BlockException ex) &#123;</span><br><span class="line">  // 资源访问阻止，被限流或被降级</span><br><span class="line">  // 在此处进行相应的处理操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特别地</strong>，若 entry 的时候传入了热点参数，那么 exit 的时候也一定要带上对应的参数（<code>exit(count, args)</code>），否则可能会有统计错误。这个时候不能使用 try-with-resources 的方式。另外通过 <code>Tracer.trace(ex)</code> 来统计异常信息时，由于 try-with-resources 语法中 catch 调用顺序的问题，会导致无法正确统计异常数，因此统计异常信息时也不能在 try-with-resources 的 catch 块中调用 <code>Tracer.trace(ex)</code>。</p>
<p>手动 exit 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Entry entry = null;</span><br><span class="line">// 务必保证 finally 会被执行</span><br><span class="line">try &#123;</span><br><span class="line">  // 资源名可使用任意有业务语义的字符串，注意数目不能太多（超过 1K），超出几千请作为参数传入而不要直接作为资源名</span><br><span class="line">  // EntryType 代表流量类型（inbound/outbound），其中系统规则只对 IN 类型的埋点生效</span><br><span class="line">  entry = SphU.entry(&quot;自定义资源名&quot;);</span><br><span class="line">  // 被保护的业务逻辑</span><br><span class="line">  // do something...</span><br><span class="line">&#125; catch (BlockException ex) &#123;</span><br><span class="line">  // 资源访问阻止，被限流或被降级</span><br><span class="line">  // 进行相应的处理操作</span><br><span class="line">&#125; catch (Exception ex) &#123;</span><br><span class="line">  // 若需要配置降级规则，需要通过这种方式记录业务异常</span><br><span class="line">  Tracer.traceEntry(ex, entry);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  // 务必保证 exit，务必保证每个 entry 与 exit 配对</span><br><span class="line">  if (entry != null) &#123;</span><br><span class="line">    entry.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>热点参数埋点示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Entry entry = null;</span><br><span class="line">try &#123;</span><br><span class="line">    // 若需要配置例外项，则传入的参数只支持基本类型。</span><br><span class="line">    // EntryType 代表流量类型，其中系统规则只对 IN 类型的埋点生效</span><br><span class="line">    // count 大多数情况都填 1，代表统计为一次调用。</span><br><span class="line">    entry = SphU.entry(resourceName, EntryType.IN, 1, paramA, paramB);</span><br><span class="line">    // Your logic here.</span><br><span class="line">&#125; catch (BlockException ex) &#123;</span><br><span class="line">    // Handle request rejection.</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 注意：exit 的时候也一定要带上对应的参数，否则可能会有统计错误。</span><br><span class="line">    if (entry != null) &#123;</span><br><span class="line">        entry.exit(1, paramA, paramB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SphU.entry()</code> 的参数描述：</p>
<p>参数名</p>
<p>类型</p>
<p>解释</p>
<p>默认值</p>
<p>entryType</p>
<p><code>EntryType</code></p>
<p>资源调用的流量类型，是入口流量（<code>EntryType.IN</code>）还是出口流量（<code>EntryType.OUT</code>），注意系统规则只对 IN 生效</p>
<p><code>EntryType.OUT</code></p>
<p>count</p>
<p><code>int</code></p>
<p>本次资源调用请求的 token 数目</p>
<p>1</p>
<p>args</p>
<p><code>Object[]</code></p>
<p>传入的参数，用于热点参数限流</p>
<p>无</p>
<p><strong>注意</strong>：<code>SphU.entry(xxx)</code> 需要与 <code>entry.exit()</code> 方法成对出现，匹配调用，否则会导致调用链记录异常，抛出 <code>ErrorEntryFreeException</code> 异常。常见的错误：</p>
<ul>
<li>自定义埋点只调用 <code>SphU.entry()</code>，没有调用 <code>entry.exit()</code></li>
<li>顺序错误，比如：<code>entry1 -&gt; entry2 -&gt; exit1 -&gt; exit2</code>，应该为 <code>entry1 -&gt; entry2 -&gt; exit2 -&gt; exit1</code></li>
</ul>
<h4 id="方式三：返回布尔值方式定义资源"><a href="#方式三：返回布尔值方式定义资源" class="headerlink" title="方式三：返回布尔值方式定义资源"></a>方式三：返回布尔值方式定义资源</h4><p><code>SphO</code> 提供 if-else 风格的 API。用这种方式，当资源发生了限流之后会返回 <code>false</code>，这个时候可以根据返回值，进行限流之后的逻辑处理。示例代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 资源名可使用任意有业务语义的字符串</span><br><span class="line">if (SphO.entry(&quot;自定义资源名&quot;)) &#123;</span><br><span class="line">  // 务必保证finally会被执行</span><br><span class="line">  try &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 被保护的业务逻辑</span><br><span class="line">    */</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    SphO.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 资源访问阻止，被限流或被降级</span><br><span class="line">  // 进行相应的处理操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>SphO.entry(xxx)</code> 需要与 SphO.exit()<code>方法成对出现，匹配调用，位置正确，否则会导致调用链记录异常，抛出</code>ErrorEntryFreeException` 异常。</p>
<h4 id="方式四：注解方式定义资源"><a href="#方式四：注解方式定义资源" class="headerlink" title="方式四：注解方式定义资源"></a>方式四：注解方式定义资源</h4><p>Sentinel 支持通过 <code>@SentinelResource</code> 注解定义资源并配置 <code>blockHandler</code> 和 <code>fallback</code> 函数来进行限流之后的处理。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 原本的业务方法.</span><br><span class="line">@SentinelResource(blockHandler = &quot;blockHandlerForGetUser&quot;)</span><br><span class="line">public User getUserById(String id) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;getUserById command failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// blockHandler 函数，原方法调用被限流/降级/系统保护的时候调用</span><br><span class="line">public User blockHandlerForGetUser(String id, BlockException ex) &#123;</span><br><span class="line">    return new User(&quot;admin&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>blockHandler</code> 函数会在原方法被限流&#x2F;降级&#x2F;系统保护的时候调用，而 <code>fallback</code> 函数会针对所有类型的异常。请注意 <code>blockHandler</code> 和 <code>fallback</code> 函数的形式要求，更多指引可以参见 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81">Sentinel 注解支持文档</a>。</p>
<h4 id="方式五：异步调用支持"><a href="#方式五：异步调用支持" class="headerlink" title="方式五：异步调用支持"></a>方式五：异步调用支持</h4><p>Sentinel 支持异步调用链路的统计。在异步调用中，需要通过 <code>SphU.asyncEntry(xxx)</code> 方法定义资源，并通常需要在异步的回调函数中调用 <code>exit</code> 方法。以下是一个简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    AsyncEntry entry = SphU.asyncEntry(resourceName);</span><br><span class="line"></span><br><span class="line">    // 异步调用.</span><br><span class="line">    doAsync(userId, result -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 在此处处理异步调用的结果.</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 在回调结束后 exit.</span><br><span class="line">            entry.exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; catch (BlockException ex) &#123;</span><br><span class="line">    // Request blocked.</span><br><span class="line">    // Handle the exception (e.g. retry or fallback).</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SphU.asyncEntry(xxx)</code> 不会影响当前（调用线程）的 Context，因此以下两个 entry 在调用链上是平级关系（处于同一层），而不是嵌套关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 调用链类似于：</span><br><span class="line">// -parent</span><br><span class="line">// ---asyncResource</span><br><span class="line">// ---syncResource</span><br><span class="line">asyncEntry = SphU.asyncEntry(asyncResource);</span><br><span class="line">entry = SphU.entry(normalResource);</span><br></pre></td></tr></table></figure>

<p>若在异步回调中需要嵌套其它的资源调用（无论是 <code>entry</code> 还是 <code>asyncEntry</code>），只需要借助 Sentinel 提供的上下文切换功能，在对应的地方通过 <code>ContextUtil.runOnContext(context, f)</code> 进行 Context 变换，将对应资源调用处的 Context 切换为生成的异步 Context，即可维持正确的调用链路关系。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void handleResult(String result) &#123;</span><br><span class="line">    Entry entry = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        entry = SphU.entry(&quot;handleResultForAsync&quot;);</span><br><span class="line">        // Handle your result here.</span><br><span class="line">    &#125; catch (BlockException ex) &#123;</span><br><span class="line">        // Blocked for the result handler.</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (entry != null) &#123;</span><br><span class="line">            entry.exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void someAsync() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        AsyncEntry entry = SphU.asyncEntry(resourceName);</span><br><span class="line"></span><br><span class="line">        // Asynchronous invocation.</span><br><span class="line">        doAsync(userId, result -&gt; &#123;</span><br><span class="line">            // 在异步回调中进行上下文变换，通过 AsyncEntry 的 getAsyncContext 方法获取异步 Context</span><br><span class="line">            ContextUtil.runOnContext(entry.getAsyncContext(), () -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 此处嵌套正常的资源调用.</span><br><span class="line">                    handleResult(result);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    entry.exit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (BlockException ex) &#123;</span><br><span class="line">        // Request blocked.</span><br><span class="line">        // Handle the exception (e.g. retry or fallback).</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的调用链就类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-parent</span><br><span class="line">---asyncInvocation</span><br><span class="line">-----handleResultForAsync</span><br></pre></td></tr></table></figure>

<p>更详细的示例可以参考 Demo 中的 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/AsyncEntryDemo.java">AsyncEntryDemo</a>，里面包含了普通资源与异步资源之间的各种嵌套示例。</p>
<h3 id="3-2-定义规则"><a href="#3-2-定义规则" class="headerlink" title="3.2.定义规则"></a>3.2.定义规则</h3><h4 id="3-2-1-规则的种类"><a href="#3-2-1-规则的种类" class="headerlink" title="3.2.1.规则的种类"></a>3.2.1.规则的种类</h4><p>Sentinel 的所有规则都可以在内存态中动态地查询及修改，修改之后立即生效。同时 Sentinel 也提供相关 API，供您来定制自己的规则策略。</p>
<p>Sentinel 支持以下几种规则：<strong>流量控制规则</strong>、<strong>熔断降级规则</strong>、<strong>系统保护规则</strong>、<strong>来源访问控制规则</strong> 和 <strong>热点参数规则</strong>。</p>
<h4 id="流量控制规则-FlowRule"><a href="#流量控制规则-FlowRule" class="headerlink" title="流量控制规则 (FlowRule)"></a>流量控制规则 (FlowRule)</h4><h5 id="流量规则的定义"><a href="#流量规则的定义" class="headerlink" title="流量规则的定义"></a>流量规则的定义</h5><p>重要属性：</p>
<p>Field</p>
<p>说明</p>
<p>默认值</p>
<p>resource</p>
<p>资源名，资源名是限流规则的作用对象</p>
<p>count</p>
<p>限流阈值</p>
<p>grade</p>
<p>限流阈值类型，QPS 模式（1）或并发线程数模式（0）</p>
<p>QPS 模式</p>
<p>limitApp</p>
<p>流控针对的调用来源</p>
<p><code>default</code>，代表不区分调用来源</p>
<p>strategy</p>
<p>调用关系限流策略：直接、链路、关联</p>
<p>根据资源本身（直接）</p>
<p>controlBehavior</p>
<p>流控效果（直接拒绝&#x2F;WarmUp&#x2F;匀速+排队等待），不支持按调用关系限流</p>
<p>直接拒绝</p>
<p>clusterMode</p>
<p>是否集群限流</p>
<p>否</p>
<p>同一个资源可以同时有多个限流规则，检查规则时会依次检查。</p>
<h5 id="通过代码定义流量控制规则"><a href="#通过代码定义流量控制规则" class="headerlink" title="通过代码定义流量控制规则"></a>通过代码定义流量控制规则</h5><p>理解上面规则的定义之后，我们可以通过调用 <code>FlowRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void initFlowQpsRule() &#123;</span><br><span class="line">    List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;();</span><br><span class="line">    FlowRule rule = new FlowRule(resourceName);</span><br><span class="line">    // set limit qps to 20</span><br><span class="line">    rule.setCount(20);</span><br><span class="line">    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    rule.setLimitApp(&quot;default&quot;);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    FlowRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多详细内容可以参考 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">流量控制</a>。</p>
<h4 id="熔断降级规则-DegradeRule"><a href="#熔断降级规则-DegradeRule" class="headerlink" title="熔断降级规则 (DegradeRule)"></a>熔断降级规则 (DegradeRule)</h4><p>熔断降级规则包含下面几个重要的属性：</p>
<p>Field</p>
<p>说明</p>
<p>默认值</p>
<p>resource</p>
<p>资源名，即规则的作用对象</p>
<p>grade</p>
<p>熔断策略，支持慢调用比例&#x2F;异常比例&#x2F;异常数策略</p>
<p>慢调用比例</p>
<p>count</p>
<p>慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例&#x2F;异常数模式下为对应的阈值</p>
<p>timeWindow</p>
<p>熔断时长，单位为 s</p>
<p>minRequestAmount</p>
<p>熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）</p>
<p>5</p>
<p>statIntervalMs</p>
<p>统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）</p>
<p>1000 ms</p>
<p>slowRatioThreshold</p>
<p>慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）</p>
<p>同一个资源可以同时有多个降级规则。</p>
<p>理解上面规则的定义之后，我们可以通过调用 <code>DegradeRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void initDegradeRule() &#123;</span><br><span class="line">    List&lt;DegradeRule&gt; rules = new ArrayList&lt;&gt;();</span><br><span class="line">    DegradeRule rule = new DegradeRule();</span><br><span class="line">    rule.setResource(KEY);</span><br><span class="line">    // set threshold RT, 10 ms</span><br><span class="line">    rule.setCount(10);</span><br><span class="line">    rule.setGrade(RuleConstant.DEGRADE_GRADE_RT);</span><br><span class="line">    rule.setTimeWindow(10);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    DegradeRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多详情可以参考 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7">熔断降级</a>。</p>
<h4 id="系统保护规则-SystemRule"><a href="#系统保护规则-SystemRule" class="headerlink" title="系统保护规则 (SystemRule)"></a>系统保护规则 (SystemRule)</h4><p>Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>
<p>系统规则包含下面几个重要的属性：</p>
<p>Field</p>
<p>说明</p>
<p>默认值</p>
<p>highestSystemLoad</p>
<p><code>load1</code> 触发值，用于触发自适应控制阶段</p>
<p>-1 (不生效)</p>
<p>avgRt</p>
<p>所有入口流量的平均响应时间</p>
<p>-1 (不生效)</p>
<p>maxThread</p>
<p>入口流量的最大并发数</p>
<p>-1 (不生效)</p>
<p>qps</p>
<p>所有入口资源的 QPS</p>
<p>-1 (不生效)</p>
<p>highestCpuUsage</p>
<p>当前系统的 CPU 使用率（0.0-1.0）</p>
<p>-1 (不生效)</p>
<p>理解上面规则的定义之后，我们可以通过调用 <code>SystemRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void initSystemRule() &#123;</span><br><span class="line">    List&lt;SystemRule&gt; rules = new ArrayList&lt;&gt;();</span><br><span class="line">    SystemRule rule = new SystemRule();</span><br><span class="line">    rule.setHighestSystemLoad(10);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    SystemRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意系统规则只针对入口资源（EntryType&#x3D;IN）生效。更多详情可以参考 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">系统自适应保护文档</a>。</p>
<h4 id="访问控制规则-AuthorityRule"><a href="#访问控制规则-AuthorityRule" class="headerlink" title="访问控制规则 (AuthorityRule)"></a>访问控制规则 (AuthorityRule)</h4><p>很多时候，我们需要根据调用方来限制资源是否通过，这时候可以使用 Sentinel 的访问控制（黑白名单）的功能。黑白名单根据资源的请求来源（<code>origin</code>）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。</p>
<p>授权规则，即黑白名单规则（<code>AuthorityRule</code>）非常简单，主要有以下配置项：</p>
<ul>
<li><code>resource</code>：资源名，即规则的作用对象</li>
<li><code>limitApp</code>：对应的黑名单&#x2F;白名单，不同 origin 用 <code>,</code> 分隔，如 <code>appA,appB</code></li>
<li><code>strategy</code>：限制模式，<code>AUTHORITY_WHITE</code> 为白名单模式，<code>AUTHORITY_BLACK</code> 为黑名单模式，默认为白名单模式</li>
</ul>
<p>更多详情可以参考 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E6%8E%A7%E5%88%B6">来源访问控制</a>。</p>
<h4 id="热点规则-ParamFlowRule"><a href="#热点规则-ParamFlowRule" class="headerlink" title="热点规则 (ParamFlowRule)"></a>热点规则 (ParamFlowRule)</h4><p>详情可以参考 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81">热点参数限流</a>。</p>
<h4 id="查询更改规则"><a href="#查询更改规则" class="headerlink" title="查询更改规则"></a>查询更改规则</h4><p>引入了 transport 模块后，可以通过以下的 HTTP API 来获取所有已加载的规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8719/getRules?type=&lt;XXXX&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>type=flow</code> 以 JSON 格式返回现有的限流规则，degrade 返回现有生效的降级规则列表，system 则返回系统保护规则。</p>
<p>获取所有热点规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8719/getParamRules</span><br></pre></td></tr></table></figure>

<h4 id="定制自己的持久化规则"><a href="#定制自己的持久化规则" class="headerlink" title="定制自己的持久化规则"></a>定制自己的持久化规则</h4><p>上面的规则配置，都是存在内存中的。即如果应用重启，这个规则就会失效。因此我们提供了开放的接口，您可以通过实现 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/blob/master/sentinel-extension/sentinel-datasource-extension/src/main/java/com/alibaba/csp/sentinel/datasource/AbstractDataSource.java"><code>DataSource</code></a> 接口的方式，来自定义规则的存储数据源。通常我们的建议有：</p>
<ul>
<li>整合动态配置系统，如 ZooKeeper、<a target="_blank" rel="noopener" href="https://github.com/alibaba/Nacos">Nacos</a>、Apollo 等，动态地实时刷新配置规则</li>
<li>结合 RDBMS、NoSQL、VCS 等来实现该规则</li>
<li>配合 Sentinel Dashboard 使用</li>
</ul>
<p>更多详情请参考 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95">动态规则配置</a>。</p>
<h3 id="3-3-规则生效的效果"><a href="#3-3-规则生效的效果" class="headerlink" title="3.3.规则生效的效果"></a>3.3.规则生效的效果</h3><h4 id="判断限流降级异常"><a href="#判断限流降级异常" class="headerlink" title="判断限流降级异常"></a>判断限流降级异常</h4><p>在 Sentinel 中所有流控降级相关的异常都是异常类 <code>BlockException</code> 的子类：</p>
<ul>
<li>流控异常：<code>FlowException</code></li>
<li>熔断降级异常：<code>DegradeException</code></li>
<li>系统保护异常：<code>SystemBlockException</code></li>
<li>热点参数限流异常：<code>ParamFlowException</code></li>
</ul>
<p>我们可以通过以下函数判断是否为 Sentinel 的流控降级异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockException.isBlockException(Throwable t);</span><br></pre></td></tr></table></figure>

<p>除了在业务代码逻辑上看到规则生效，我们也可以通过下面简单的方法，来校验规则生效的效果：</p>
<ul>
<li><strong>暴露的 HTTP 接口</strong>：通过运行下面命令 <code>curl http://localhost:8719/cnode?id=&lt;资源名称&gt;</code>，观察返回的数据。如果规则生效，在返回的数据栏中的 <code>block</code> 以及 <code>block(m)</code> 中会有显示</li>
<li><strong>日志</strong>：Sentinel 提供秒级的资源运行日志以及限流日志，详情可以参考: <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E6%97%A5%E5%BF%97">日志</a></li>
</ul>
<h4 id="block-事件"><a href="#block-事件" class="headerlink" title="block 事件"></a>block 事件</h4><p>Sentinel 提供以下扩展接口，可以通过 <code>StatisticSlotCallbackRegistry</code> 向 <code>StatisticSlot</code> 注册回调函数：</p>
<ul>
<li><code>ProcessorSlotEntryCallback</code>: callback when resource entry passed (<code>onPass</code>) or blocked (<code>onBlocked</code>)</li>
<li><code>ProcessorSlotExitCallback</code>: callback when resource entry successfully completed (<code>onExit</code>)</li>
</ul>
<p>可以利用这些回调接口来实现报警等功能，实时的监控信息可以从 <code>ClusterNode</code> 中实时获取。</p>
<h2 id="4-其它-API"><a href="#4-其它-API" class="headerlink" title="4.其它 API"></a>4.其它 API</h2><h3 id="4-1-业务异常统计-Tracer"><a href="#4-1-业务异常统计-Tracer" class="headerlink" title="4.1.业务异常统计 Tracer"></a>4.1.业务异常统计 Tracer</h3><p>业务异常记录类 <code>Tracer</code> 用于记录业务异常。相关方法：</p>
<ul>
<li><code>traceEntry(Throwable, Entry)</code>：向传入 entry 对应的资源记录业务异常（非 <code>BlockException</code> 异常），异常数目为传入的 <code>count</code>。</li>
</ul>
<p>如果用户通过 <code>SphU</code> 或 <code>SphO</code> 手动定义资源，则 Sentinel 不能感知上层业务的异常，需要手动调用 <code>Tracer.trace(ex)</code> 来记录业务异常，否则对应的异常不会统计到 Sentinel 异常计数中。注意不要在 try-with-resources 形式的 <code>SphU.entry(xxx)</code> 中使用，否则会统计不上。</p>
<p>从 1.3.1 版本开始，注解方式定义资源支持自动统计业务异常，无需手动调用 <code>Tracer.trace(ex)</code> 来记录业务异常。Sentinel 1.3.1 以前的版本需要手动记录。</p>
<h3 id="4-2-上下文工具类-ContextUtil"><a href="#4-2-上下文工具类-ContextUtil" class="headerlink" title="4.2.上下文工具类 ContextUtil"></a>4.2.上下文工具类 ContextUtil</h3><p>相关静态方法：</p>
<p><strong>标识进入调用链入口（上下文）</strong>：</p>
<p>以下静态方法用于标识调用链路入口，用于区分不同的调用链路：</p>
<ul>
<li><code>public static Context enter(String contextName)</code></li>
<li><code>public static Context enter(String contextName, String origin)</code></li>
</ul>
<p>其中 <code>contextName</code> 代表调用链路入口名称（上下文名称），<code>origin</code> 代表调用来源名称。默认调用来源为空。返回值类型为 <code>Context</code>，即生成的调用链路上下文对象。</p>
<p>流控规则中若选择“流控方式”为“链路”方式，则入口资源名即为上面的 <code>contextName</code>。</p>
<p><strong>注意</strong>：</p>
<ul>
<li><code>ContextUtil.enter(xxx)</code> 方法仅在调用链路入口处生效，即仅在当前线程的初次调用生效，后面再调用不会覆盖当前线程的调用链路，直到 exit。<code>Context</code> 存于 ThreadLocal 中，因此切换线程时可能会丢掉，如果需要跨线程使用可以结合 <code>runOnContext</code> 方法使用。</li>
<li>origin 数量不要太多，否则内存占用会比较大。</li>
</ul>
<p><strong>退出调用链（清空上下文）</strong>：</p>
<ul>
<li><code>public static void exit()</code>：该方法用于退出调用链，清理当前线程的上下文。</li>
</ul>
<p><strong>获取当前线程的调用链上下文</strong>：</p>
<ul>
<li><code>public static Context getContext()</code>：获取当前线程的调用链路上下文对象。</li>
</ul>
<p><strong>在某个调用链上下文中执行代码</strong>：</p>
<ul>
<li><code>public static void runOnContext(Context context, Runnable f)</code>：常用于异步调用链路中 context 的变换。</li>
</ul>
<h2 id="5-springcloud整合sentinel"><a href="#5-springcloud整合sentinel" class="headerlink" title="5.springcloud整合sentinel"></a>5.springcloud整合sentinel</h2><h3 id="5-1-sentinel依赖"><a href="#5-1-sentinel依赖" class="headerlink" title="5.1.sentinel依赖"></a>5.1.sentinel依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--sentinel：熔断、降级、限流--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-下载控制台Dashboard"><a href="#5-2-下载控制台Dashboard" class="headerlink" title="5.2.下载控制台Dashboard"></a>5.2.下载控制台Dashboard</h3><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases">控制台下载</a></p>
<blockquote>
<p>查看sentinel-core的版本，当前使用1.7.1<br>下载sentinel-dashboard-1.7.1.jar</p>
<p>启动：<br>java -Dserver.port&#x3D;8333 -Dcsp.sentinel.dashboard.server&#x3D;127.0.0.1:8333 -Dproject.name&#x3D;sentinel-dashboard -jar sentinel-dashboard-1.7.1.jar</p>
</blockquote>
<h3 id="5-3-配置dashboard属性"><a href="#5-3-配置dashboard属性" class="headerlink" title="5.3.配置dashboard属性"></a>5.3.配置dashboard属性</h3><p>控制台工作流程：</p>
<p>​ 1.控制台配置限流规则，然后将限流规则推送给应用（所以应用所在机器需要启动一个server port接收控制台消息）</p>
<p>​ 2.应用接收到限流规则后，再将规则注册到sentinel中（所以还需要配置sentinel的服务地址:port）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 每个模块都要配置【如果本机启动端口会冲突，编排好端口】</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        # 应用开启端口，接收dashboard限流规则</span><br><span class="line">        port: 8719</span><br><span class="line">        # 控制台信息</span><br><span class="line">        dashboard: 127.0.0.1:8333</span><br></pre></td></tr></table></figure>

<h3 id="5-4-在dashboard操作"><a href="#5-4-在dashboard操作" class="headerlink" title="5.4.在dashboard操作"></a>5.4.在dashboard操作</h3><p><strong>规则</strong></p>
<p>Field</p>
<p>说明</p>
<p>默认值</p>
<p>resource</p>
<p>资源名，资源名是限流规则的作用对象</p>
<p>count</p>
<p>限流阈值</p>
<p>grade</p>
<p>限流阈值类型，QPS 模式（1）或并发线程数模式（0）</p>
<p>QPS 模式</p>
<p>limitApp</p>
<p>流控针对的调用来源</p>
<p><code>default</code>，代表不区分调用来源</p>
<p>strategy</p>
<p>调用关系限流策略：直接、链路、关联</p>
<p>根据资源本身（直接）</p>
<p>controlBehavior</p>
<p>流控效果（直接拒绝&#x2F;WarmUp&#x2F;匀速+排队等待），不支持按调用关系限流</p>
<p>直接拒绝</p>
<p>clusterMode</p>
<p>是否集群限流</p>
<p>否</p>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/gulimall-dev/1641546092678.png" alt="1641546092678"></p>
<h4 id="5-4-1-限流"><a href="#5-4-1-限流" class="headerlink" title="5.4.1.限流"></a>5.4.1.限流</h4><p><img src="https://halo-ctc.upyun.ctcnb.cn/gulimall-dev/1641546155682.png" alt="1641546155682"></p>
<p><strong>限流效果：</strong></p>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/gulimall-dev/1641546236638.png" alt="1641546236638"></p>
<h5 id="5-4-1-1-流控模式"><a href="#5-4-1-1-流控模式" class="headerlink" title="5.4.1.1 流控模式"></a>5.4.1.1 流控模式</h5><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">流控模式文档</a></p>
<blockquote>
<p>调用关系包括调用方、被调用方；一个方法又可能会调用其它方法，形成一个调用链路的层次关系。Sentinel 通过 NodeSelectorSlot 建立不同资源间的调用的关系，并且通过 ClusterBuilderSlot 记录每个资源的实时统计信息。</p>
<p>有了调用链路的统计信息，我们可以衍生出多种流量控制手段。</p>
<p>直接：<br>所有调用此资源的请求都受该规则控制<br>关联：<br>资源A和资源B关联限流，如果A流量大则限流B<br>链路：<br>指定请求调用入口，只有从入口过来的请求受该规则控制</p>
</blockquote>
<h6 id="根据调用方限流"><a href="#根据调用方限流" class="headerlink" title="根据调用方限流"></a>根据调用方限流</h6><p>​ <code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数标明了调用方身份。这些信息会在 <code>ClusterBuilderSlot</code> 中被统计。可通过以下命令来展示不同的调用方对同一个资源的调用数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8719/origin?id=nodeA</span><br></pre></td></tr></table></figure>

<p>调用数据示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id: nodeA</span><br><span class="line">idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total </span><br><span class="line">1   caller1 0         0         0          0        0     0         0          0</span><br><span class="line">2   caller2 0         0         0          0        0     0         0          0</span><br></pre></td></tr></table></figure>

<p>上面这个命令展示了资源名为 <code>nodeA</code> 的资源被两个不同的调用方调用的统计。</p>
<p>流控规则中的 <code>limitApp</code> 字段用于根据调用来源进行流量控制。该字段的值有以下三种选项，分别对应不同的场景：</p>
<ul>
<li><code>default</code>：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则触发限流。</li>
<li><code>&#123;some_origin_name&#125;</code>：表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如 <code>NodeA</code> 配置了一条针对调用者<code>caller1</code>的规则，那么当且仅当来自 <code>caller1</code> 对 <code>NodeA</code> 的请求才会触发流量控制。</li>
<li><code>other</code>：表示针对除 <code>&#123;some_origin_name&#125;</code> 以外的其余调用方的流量进行流量控制。例如，资源<code>NodeA</code>配置了一条针对调用者 <code>caller1</code> 的限流规则，同时又配置了一条调用者为 <code>other</code> 的规则，那么任意来自非 <code>caller1</code> 对 <code>NodeA</code> 的调用，都不能超过 <code>other</code> 这条规则定义的阈值。</li>
</ul>
<p>同一个资源名可以配置多条规则，规则的生效顺序为：**{some_origin_name} &gt; other &gt; default**</p>
<blockquote>
<p>注意：调用来源的数目不要太多（一般不要超过几百个），否则内存占用会非常多（调用来源的统计节点最大数目&#x3D;资源数目*来源数目）。</p>
</blockquote>
<h6 id="根据调用链路入口限流：链路限流"><a href="#根据调用链路入口限流：链路限流" class="headerlink" title="根据调用链路入口限流：链路限流"></a>根据调用链路入口限流：链路限流</h6><p>​ <code>NodeSelectorSlot</code> 中记录了资源之间的调用链路，这些资源通过调用关系，相互之间构成一棵调用树。这棵树的根节点是一个名字为 <code>machine-root</code> 的虚拟节点，调用链的入口都是这个虚节点的子节点。</p>
<p>一棵典型的调用树如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">             machine-root</span><br><span class="line">              /       \</span><br><span class="line">             /         \</span><br><span class="line">       Entrance1     Entrance2</span><br><span class="line">          /             \</span><br><span class="line">         /               \</span><br><span class="line">DefaultNode(nodeA)   DefaultNode(nodeA)</span><br></pre></td></tr></table></figure>

<p>上图中来自入口 <code>Entrance1</code> 和 <code>Entrance2</code> 的请求都调用到了资源 <code>NodeA</code>，Sentinel 允许只根据某个入口的统计信息对资源限流。比如我们可以设置 <code>strategy</code> 为 <code>RuleConstant.STRATEGY_CHAIN</code>，同时设置 <code>refResource</code> 为 <code>Entrance1</code> 来表示只有从入口 <code>Entrance1</code> 的调用才会记录到 <code>NodeA</code> 的限流统计当中，而不关心经 <code>Entrance2</code> 到来的调用。</p>
<p>调用链的入口（上下文）是通过 API 方法 <code>ContextUtil.enter(contextName)</code> 定义的，其中 contextName 即对应调用链路入口名称。详情可以参考 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%A5%E5%85%B7%E7%B1%BB-contextutil">ContextUtil 文档</a>。</p>
<h6 id="具有关系的资源流量控制：关联流量控制"><a href="#具有关系的资源流量控制：关联流量控制" class="headerlink" title="具有关系的资源流量控制：关联流量控制"></a>具有关系的资源流量控制：关联流量控制</h6><p>​ 当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，<code>read_db</code> 和 <code>write_db</code> 这两个资源分别代表数据库读写，我们可以给 <code>read_db</code> 设置限流规则来达到写优先的目的：设置 <code>strategy</code> 为 <code>RuleConstant.STRATEGY_RELATE</code> 同时设置 <code>refResource</code> 为 <code>write_db</code>。这样当写库操作过于频繁时，读数据的请求会被限流。</p>
<h4 id="5-4-1-2-流控效果"><a href="#5-4-1-2-流控效果" class="headerlink" title="5.4.1.2 流控效果"></a>5.4.1.2 流控效果</h4><h5 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h5><blockquote>
<p>超出阈值的直接丢弃</p>
</blockquote>
<h5 id="Warm-Up"><a href="#Warm-Up" class="headerlink" title="Warm Up"></a>Warm Up</h5><blockquote>
<p>在一段时间内将请求数放行到阈值</p>
</blockquote>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/gulimall-dev/1641565682745.png" alt="1641565682745"></p>
<h5 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h5><blockquote>
<p>超出阈值的请求排队，如果超时仍未处理的请求被丢弃</p>
</blockquote>
<h4 id="5-4-2-熔断"><a href="#5-4-2-熔断" class="headerlink" title="5.4.2.熔断"></a>5.4.2.熔断</h4><blockquote>
<p>熔断适配feign，远程调用快速失败<br>注意：<br>熔断是在调用方配置，以下在调用方product测试<br>熔断可以看做一种回调机制，调用方设置feign降级，会触发回调</p>
</blockquote>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/gulimall-dev/1641566889856.png" alt="1641566889856"></p>
<h5 id="Feign-支持"><a href="#Feign-支持" class="headerlink" title="Feign 支持"></a>Feign 支持</h5><p>Sentinel 适配了 <a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">Feign</a> 组件。如果想使用，除了引入 <code>spring-cloud-starter-alibaba-sentinel</code> 的依赖外还需要 2 个步骤：</p>
<ul>
<li>配置文件打开 Sentinel 对 Feign 的支持：<code>feign.sentinel.enabled=true</code></li>
<li>加入 <code>spring-cloud-starter-openfeign</code> 依赖使 Sentinel starter 中的自动化配置类生效：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>这是一个 <code>FeignClient</code> 的简单使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 指定配置类，熔断回调类</span><br><span class="line">@FeignClient(name = &quot;service-provider&quot;, fallback = EchoServiceFallback.class, configuration = FeignConfiguration.class)</span><br><span class="line">public interface EchoService &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/echo/&#123;str&#125;&quot;, method = RequestMethod.GET)</span><br><span class="line">    String echo(@PathVariable(&quot;str&quot;) String str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 配置类</span><br><span class="line">class FeignConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public EchoServiceFallback echoServiceFallback() &#123;</span><br><span class="line">        return new EchoServiceFallback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 熔断回调类</span><br><span class="line">class EchoServiceFallback implements EchoService &#123;</span><br><span class="line">    // 熔断回调方法</span><br><span class="line">    @Override</span><br><span class="line">    public String echo(@PathVariable(&quot;str&quot;) String str) &#123;</span><br><span class="line">        return &quot;echo fallback&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note</p>
<p>Feign 对应的接口中的资源名策略定义：httpmethod:protocol:&#x2F;&#x2F;requesturl。<code>@FeignClient</code> 注解中的所有属性，Sentinel 都做了兼容。</p>
<p><code>EchoService</code> 接口中方法 <code>echo</code> 对应的资源名为 <code>GET:http://service-provider/echo/&#123;str&#125;</code>。</p>
<h4 id="5-4-3-降级"><a href="#5-4-3-降级" class="headerlink" title="5.4.3.降级"></a>5.4.3.降级</h4><p>1**.宕机的feign请求**会触发熔断fallback</p>
<p>2.<strong>调用方设置feign请求降级规则</strong>，降级后触发熔断fallback</p>
<p>3.<strong>调用方不设置feign降级，而提供方设置controller资源降级</strong>，降级后触发提供方的限流handle处理（UrlBlockSentinelHandler）一般用作高并发场景下让出资源</p>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/gulimall-dev/1641570662185.png" alt="1641570662185"></p>
<blockquote>
<p>熔断方法一般是服务的调用方提供 降级方法一般由服务的提供方提供。</p>
<p>例：A调用B：1、调用不到，得到A自己设置的熔断数据 2、能调用B，但是B自己设置了降级。那么A得到的是B降级数据</p>
</blockquote>
<h3 id="5-5-dashboard实时监控【Endpoint-支持】"><a href="#5-5-dashboard实时监控【Endpoint-支持】" class="headerlink" title="5.5.dashboard实时监控【Endpoint 支持】"></a>5.5.dashboard实时监控【Endpoint 支持】</h3><blockquote>
<p>在使用 Endpoint 特性之前需要在 Maven 中添加 spring-boot-starter-actuator 依赖，并在配置中允许 Endpoints 的访问。<br>Spring Boot 1.x 中添加配置 management.security.enabled&#x3D;false。暴露的 endpoint 路径为 &#x2F;sentinel<br>Spring Boot 2.x 中添加配置 management.endpoints.web.exposure.include&#x3D;*。暴露的 endpoint 路径为 &#x2F;actuator&#x2F;sentinel</p>
<p>注意：<br>spring-boot-starter-actuator是审计框架，计算springboot应用健康状况信息、请求的调用信息<br>dashboard可以拿到actuator数据作实时监控统计</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--审计模块，监控应用的健康情况、调用信息--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2.暴露端口，属性配置</span><br><span class="line"></span><br><span class="line"># 审计模块暴露</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        exclude: &#x27;*&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="5-6-url资源限流"><a href="#5-6-url资源限流" class="headerlink" title="5.6.url资源限流"></a>5.6.url资源限流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认限流返回Blocked by Sentinel</span><br><span class="line">可以实现自定义限流的返回页面，实现 请求限制处理器</span><br></pre></td></tr></table></figure>

<p>默认返回：</p>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/gulimall-dev/1641546236638.png" alt="1641546236638"></p>
<p>自定义返回：</p>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20230114164158516.png" alt="image-20230114164158516"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">新版本：【在每个模块添加该配置】</span><br><span class="line">/**</span><br><span class="line"> * @Description: 限流请求自定义返回</span><br><span class="line"> **/</span><br><span class="line">@Component</span><br><span class="line">public class UrlBlockHandler implements BlockExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自定义限流返回信息</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param ex</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void handle(HttpServletRequest request, HttpServletResponse response, BlockException ex) throws IOException &#123;</span><br><span class="line">        R error = R.error(BizCodeEnume.TO_MANY_REQUEST.getCode(), BizCodeEnume.TO_MANY_REQUEST.getMsg());</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setContentType(&quot;application/json&quot;);</span><br><span class="line">        response.getWriter().write(JSON.toJSONString(error));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-7-自定义资源限流"><a href="#5-7-自定义资源限流" class="headerlink" title="5.7.自定义资源限流"></a>5.7.自定义资源限流</h3><p>文档：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8#%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90">自定义资源</a></p>
<blockquote>
<p>资源可以是一个方法、一个请求、甚至是一段代码</p>
</blockquote>
<h4 id="5-7-1-抛出异常的方式定义资源"><a href="#5-7-1-抛出异常的方式定义资源" class="headerlink" title="5.7.1 抛出异常的方式定义资源"></a>5.7.1 抛出异常的方式定义资源</h4><ol>
<li>使用try catch包含资源代码 </li>
<li>指定这段代码的资源名 </li>
<li>在dashboard上根据资源名设置限流规则、降级规则</li>
</ol>
<blockquote>
<p><code>SphU</code> 包含了 try-catch 风格的 API。用这种方式，当资源发生了限流之后会抛出 <code>BlockException</code>。这个时候可以捕捉异常，进行限流之后的逻辑处理。示例代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1.5.0 版本开始可以利用 try-with-resources 特性（使用有限制）</span><br><span class="line">// 资源名可使用任意有业务语义的字符串，比如方法名、接口名或其它可唯一标识的字符串。</span><br><span class="line">try (Entry entry = SphU.entry(&quot;resourceName&quot;)) &#123;</span><br><span class="line">  // 被保护的业务逻辑</span><br><span class="line">  // do something here...</span><br><span class="line">&#125; catch (BlockException ex) &#123;</span><br><span class="line">  // 资源访问阻止，被限流或被降级</span><br><span class="line">  // 在此处进行相应的处理操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特别地</strong>，若 entry 的时候传入了热点参数，那么 exit 的时候也一定要带上对应的参数（<code>exit(count, args)</code>），否则可能会有统计错误。这个时候不能使用 try-with-resources 的方式。另外通过 <code>Tracer.trace(ex)</code> 来统计异常信息时，由于 try-with-resources 语法中 catch 调用顺序的问题，会导致无法正确统计异常数，因此统计异常信息时也不能在 try-with-resources 的 catch 块中调用 <code>Tracer.trace(ex)</code>。</p>
<p>手动 exit 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Entry entry = null;</span><br><span class="line">// 务必保证 finally 会被执行</span><br><span class="line">try &#123;</span><br><span class="line">  // 资源名可使用任意有业务语义的字符串，注意数目不能太多（超过 1K），超出几千请作为参数传入而不要直接作为资源名</span><br><span class="line">  // EntryType 代表流量类型（inbound/outbound），其中系统规则只对 IN 类型的埋点生效</span><br><span class="line">  entry = SphU.entry(&quot;自定义资源名&quot;);</span><br><span class="line">  // 被保护的业务逻辑</span><br><span class="line">  // do something...</span><br><span class="line">&#125; catch (BlockException ex) &#123;</span><br><span class="line">  // 资源访问阻止，被限流或被降级</span><br><span class="line">  // 进行相应的处理操作</span><br><span class="line">&#125; catch (Exception ex) &#123;</span><br><span class="line">  // 若需要配置降级规则，需要通过这种方式记录业务异常</span><br><span class="line">  Tracer.traceEntry(ex, entry);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  // 务必保证 exit，务必保证每个 entry 与 exit 配对</span><br><span class="line">  if (entry != null) &#123;</span><br><span class="line">    entry.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>热点参数埋点示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Entry entry = null;</span><br><span class="line">try &#123;</span><br><span class="line">    // 若需要配置例外项，则传入的参数只支持基本类型。</span><br><span class="line">    // EntryType 代表流量类型，其中系统规则只对 IN 类型的埋点生效</span><br><span class="line">    // count 大多数情况都填 1，代表统计为一次调用。</span><br><span class="line">    entry = SphU.entry(resourceName, EntryType.IN, 1, paramA, paramB);</span><br><span class="line">    // Your logic here.</span><br><span class="line">&#125; catch (BlockException ex) &#123;</span><br><span class="line">    // Handle request rejection.</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 注意：exit 的时候也一定要带上对应的参数，否则可能会有统计错误。</span><br><span class="line">    if (entry != null) &#123;</span><br><span class="line">        entry.exit(1, paramA, paramB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SphU.entry()</code> 的参数描述：</p>
<p>参数名</p>
<p>类型</p>
<p>解释</p>
<p>默认值</p>
<p>entryType</p>
<p><code>EntryType</code></p>
<p>资源调用的流量类型，是入口流量（<code>EntryType.IN</code>）还是出口流量（<code>EntryType.OUT</code>），注意系统规则只对 IN 生效</p>
<p><code>EntryType.OUT</code></p>
<p>count</p>
<p><code>int</code></p>
<p>本次资源调用请求的 token 数目</p>
<p>1</p>
<p>args</p>
<p><code>Object[]</code></p>
<p>传入的参数，用于热点参数限流</p>
<p>无</p>
<p><strong>注意</strong>：<code>SphU.entry(xxx)</code> 需要与 <code>entry.exit()</code> 方法成对出现，匹配调用，否则会导致调用链记录异常，抛出 <code>ErrorEntryFreeException</code> 异常。常见的错误：</p>
<ul>
<li>自定义埋点只调用 <code>SphU.entry()</code>，没有调用 <code>entry.exit()</code></li>
<li>顺序错误，比如：<code>entry1 -&gt; entry2 -&gt; exit1 -&gt; exit2</code>，应该为 <code>entry1 -&gt; entry2 -&gt; exit2 -&gt; exit1</code></li>
</ul>
</blockquote>
<h4 id="5-7-2-注解资源限流"><a href="#5-7-2-注解资源限流" class="headerlink" title="5.7.2 注解资源限流"></a>5.7.2 注解资源限流</h4><p>Sentinel 支持通过 <code>@SentinelResource</code> 注解定义资源并配置 <code>blockHandler</code> 和 <code>fallback</code> 函数来进行限流之后的处理。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 原本的业务方法.</span><br><span class="line">@SentinelResource(blockHandler = &quot;blockHandlerForGetUser&quot;)</span><br><span class="line">public User getUserById(String id) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;getUserById command failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// blockHandler 函数，原方法调用被限流/降级/系统保护的时候调用</span><br><span class="line">public User blockHandlerForGetUser(String id, BlockException ex) &#123;</span><br><span class="line">    return new User(&quot;admin&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>blockHandler</code> 函数会在原方法被限流&#x2F;降级&#x2F;系统保护的时候调用，而 <code>fallback</code> 函数会针对所有类型的异常。请注意 <code>blockHandler</code> 和 <code>fallback</code> 函数的形式要求，更多指引可以参见 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81">Sentinel 注解支持文档</a>。</p>
<h3 id="5-8-网关限流"><a href="#5-8-网关限流" class="headerlink" title="5.8 网关限流"></a>5.8 网关限流</h3><p>文档：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81">网关限流</a></p>
<p>Sentinel 支持对 Spring Cloud Gateway、Zuul 等主流的 API Gateway 进行限流。</p>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/583817703.png" alt="583817703"></p>
<p><strong>使用流程：</strong></p>
<ol>
<li>引入依赖</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--网关限流适配，版本号要与spring-cloud-alibaba-dependencies一致--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-spring-cloud-gateway-adapter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;x.y.z&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Sentinel 控制台会自动显示网关对应的菜单，可以查看实时的 route 和自定义 API 分组的监控和调用信息，并针对其配置规则：</li>
</ol>
<p><img src="https://halo-ctc.upyun.ctcnb.cn/typore/image-20230114192451125.png" alt="image-20230114192451125"></p>
<p>​ 网关规则动态配置及网关集群流控可以参考 <a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/118482.html">AHAS Sentinel 网关流控</a>。</p>
<p><strong>自定义回调</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author : ctc</span><br><span class="line"> * @createTime : 2023/1/14 19:35</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class SentinelGetewayConfig &#123;</span><br><span class="line"></span><br><span class="line">    public SentinelGetewayConfig()&#123;</span><br><span class="line">        GatewayCallbackManager.setBlockHandler(new BlockRequestHandler() &#123;</span><br><span class="line">            // 网关限流了请求，就会调用此回调</span><br><span class="line">            @Override</span><br><span class="line">            public Mono&lt;ServerResponse&gt; handleRequest(ServerWebExchange serverWebExchange, Throwable throwable) &#123;</span><br><span class="line">                R r = R.error(BizCodeEnume.TO_MANY_REQUEST.getCode(), BizCodeEnume.TO_MANY_REQUEST.getMsg());</span><br><span class="line">                String errJson = JSON.toJSONString(r);</span><br><span class="line">                return ServerResponse.ok().body(Mono.just(errJson), String.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://020327.xyz">阿库娅</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://020327.xyz/2023/01/7bc9b569e5a0.html">http://020327.xyz/2023/01/7bc9b569e5a0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://020327.xyz" target="_blank">编程小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/spring/">spring</a><a class="post-meta__tags" href="/tags/alibaba/">alibaba</a><a class="post-meta__tags" href="/tags/springcloud/">springcloud</a></div><div class="post_share"><div class="social-share" data-image="https://common.ctcnb.cn/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/ca1c32a076ce.html" title="Linux开启ssh并允许root登录（ubuntu）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux开启ssh并允许root登录（ubuntu）</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/0cd74a829f6c.html" title="线程池和异步编排"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">线程池和异步编排</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/631b03fcdc2f.html" title="压力测试和JMeter的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">压力测试和JMeter的使用</div></div></a></div><div><a href="/2023/03/991533426f94.html" title="java知识点——框架篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">java知识点——框架篇</div></div></a></div><div><a href="/2023/01/0cd74a829f6c.html" title="线程池和异步编排"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-13</div><div class="title">线程池和异步编排</div></div></a></div><div><a href="/2023/05/82d30b456e13.html" title="使用docker部署springboot项目"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-12</div><div class="title">使用docker部署springboot项目</div></div></a></div><div><a href="/2023/01/ddcc18613be5.html" title="RabbitMQ"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-02</div><div class="title">RabbitMQ</div></div></a></div><div><a href="/2022/11/001538ef2a61.html" title="java知识点-基础篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-15</div><div class="title">java知识点-基础篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://common.ctcnb.cn/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">阿库娅</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ctcnb"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ctcnb" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:ctcnb1@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.</span> <span class="toc-text">1.总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%86%94%E6%96%AD"><span class="toc-number">1.2.</span> <span class="toc-text">2.熔断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%99%8D%E7%BA%A7"><span class="toc-number">1.3.</span> <span class="toc-text">3.降级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%8D%E7%BA%A7%E5%BC%82%E5%90%8C%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">4.熔断与降级异同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%99%90%E6%B5%81"><span class="toc-number">1.5.</span> <span class="toc-text">5.限流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">2.</span> <span class="toc-text">二、实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Hystrix"><span class="toc-number">2.1.</span> <span class="toc-text">1.Hystrix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Sentinel"><span class="toc-number">2.2.</span> <span class="toc-text">2.Sentinel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Hystrix%E3%80%81Sentinel%E5%AF%B9%E6%AF%94%E5%9B%BE"><span class="toc-number">2.3.</span> <span class="toc-text">3.Hystrix、Sentinel对比图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Sentinel"><span class="toc-number">3.</span> <span class="toc-text">三、Sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%87%E6%A1%A3"><span class="toc-number">3.1.</span> <span class="toc-text">1.文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.2.</span> <span class="toc-text">2.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.3.</span> <span class="toc-text">3.使用步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1.定义资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E9%80%82%E9%85%8D"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">方式一：主流框架的默认适配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">方式二：抛出异常的方式定义资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%B8%83%E5%B0%94%E5%80%BC%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">方式三：返回布尔值方式定义资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E5%9B%9B%EF%BC%9A%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">方式四：注解方式定义资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%94%EF%BC%9A%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%94%AF%E6%8C%81"><span class="toc-number">3.3.1.5.</span> <span class="toc-text">方式五：异步调用支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2.定义规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E8%A7%84%E5%88%99%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">3.2.1.规则的种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%A7%84%E5%88%99-FlowRule"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">流量控制规则 (FlowRule)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.2.2.1.</span> <span class="toc-text">流量规则的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E5%AE%9A%E4%B9%89%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%A7%84%E5%88%99"><span class="toc-number">3.3.2.2.2.</span> <span class="toc-text">通过代码定义流量控制规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E8%A7%84%E5%88%99-DegradeRule"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">熔断降级规则 (DegradeRule)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E4%BF%9D%E6%8A%A4%E8%A7%84%E5%88%99-SystemRule"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">系统保护规则 (SystemRule)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E8%A7%84%E5%88%99-AuthorityRule"><span class="toc-number">3.3.2.5.</span> <span class="toc-text">访问控制规则 (AuthorityRule)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E8%A7%84%E5%88%99-ParamFlowRule"><span class="toc-number">3.3.2.6.</span> <span class="toc-text">热点规则 (ParamFlowRule)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9B%B4%E6%94%B9%E8%A7%84%E5%88%99"><span class="toc-number">3.3.2.7.</span> <span class="toc-text">查询更改规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E8%A7%84%E5%88%99"><span class="toc-number">3.3.2.8.</span> <span class="toc-text">定制自己的持久化规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%A7%84%E5%88%99%E7%94%9F%E6%95%88%E7%9A%84%E6%95%88%E6%9E%9C"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.规则生效的效果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%99%90%E6%B5%81%E9%99%8D%E7%BA%A7%E5%BC%82%E5%B8%B8"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">判断限流降级异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">block 事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B6%E5%AE%83-API"><span class="toc-number">3.4.</span> <span class="toc-text">4.其它 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%B8%9A%E5%8A%A1%E5%BC%82%E5%B8%B8%E7%BB%9F%E8%AE%A1-Tracer"><span class="toc-number">3.4.1.</span> <span class="toc-text">4.1.业务异常统计 Tracer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%A5%E5%85%B7%E7%B1%BB-ContextUtil"><span class="toc-number">3.4.2.</span> <span class="toc-text">4.2.上下文工具类 ContextUtil</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-springcloud%E6%95%B4%E5%90%88sentinel"><span class="toc-number">3.5.</span> <span class="toc-text">5.springcloud整合sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-sentinel%E4%BE%9D%E8%B5%96"><span class="toc-number">3.5.1.</span> <span class="toc-text">5.1.sentinel依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%B8%8B%E8%BD%BD%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard"><span class="toc-number">3.5.2.</span> <span class="toc-text">5.2.下载控制台Dashboard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%85%8D%E7%BD%AEdashboard%E5%B1%9E%E6%80%A7"><span class="toc-number">3.5.3.</span> <span class="toc-text">5.3.配置dashboard属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%9C%A8dashboard%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.4.</span> <span class="toc-text">5.4.在dashboard操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E9%99%90%E6%B5%81"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">5.4.1.限流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-1-1-%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.4.1.1.</span> <span class="toc-text">5.4.1.1 流控模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%B0%83%E7%94%A8%E6%96%B9%E9%99%90%E6%B5%81"><span class="toc-number">3.5.4.1.1.1.</span> <span class="toc-text">根据调用方限流</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E5%85%A5%E5%8F%A3%E9%99%90%E6%B5%81%EF%BC%9A%E9%93%BE%E8%B7%AF%E9%99%90%E6%B5%81"><span class="toc-number">3.5.4.1.1.2.</span> <span class="toc-text">根据调用链路入口限流：链路限流</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%85%B3%E7%B3%BB%E7%9A%84%E8%B5%84%E6%BA%90%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9A%E5%85%B3%E8%81%94%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.5.4.1.1.3.</span> <span class="toc-text">具有关系的资源流量控制：关联流量控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-2-%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C"><span class="toc-number">3.5.4.2.</span> <span class="toc-text">5.4.1.2 流控效果</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5"><span class="toc-number">3.5.4.2.1.</span> <span class="toc-text">快速失败</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Warm-Up"><span class="toc-number">3.5.4.2.2.</span> <span class="toc-text">Warm Up</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E9%98%9F%E7%AD%89%E5%BE%85"><span class="toc-number">3.5.4.2.3.</span> <span class="toc-text">排队等待</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-%E7%86%94%E6%96%AD"><span class="toc-number">3.5.4.3.</span> <span class="toc-text">5.4.2.熔断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Feign-%E6%94%AF%E6%8C%81"><span class="toc-number">3.5.4.3.1.</span> <span class="toc-text">Feign 支持</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-%E9%99%8D%E7%BA%A7"><span class="toc-number">3.5.4.4.</span> <span class="toc-text">5.4.3.降级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-dashboard%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E3%80%90Endpoint-%E6%94%AF%E6%8C%81%E3%80%91"><span class="toc-number">3.5.5.</span> <span class="toc-text">5.5.dashboard实时监控【Endpoint 支持】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-url%E8%B5%84%E6%BA%90%E9%99%90%E6%B5%81"><span class="toc-number">3.5.6.</span> <span class="toc-text">5.6.url资源限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E9%99%90%E6%B5%81"><span class="toc-number">3.5.7.</span> <span class="toc-text">5.7.自定义资源限流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-1-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90"><span class="toc-number">3.5.7.1.</span> <span class="toc-text">5.7.1 抛出异常的方式定义资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-2-%E6%B3%A8%E8%A7%A3%E8%B5%84%E6%BA%90%E9%99%90%E6%B5%81"><span class="toc-number">3.5.7.2.</span> <span class="toc-text">5.7.2 注解资源限流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81"><span class="toc-number">3.5.8.</span> <span class="toc-text">5.8 网关限流</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/860d24e4422f.html" title="在绿联上安装clouddrive2">在绿联上安装clouddrive2</a><time datetime="2024-07-07T02:22:00.000Z" title="发表于 2024-07-07 10:22:00">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/90f860897346.html" title="使用github和cloudflare实现自建docker加速器，解决docker镜像无法拉取的问题">使用github和cloudflare实现自建docker加速器，解决docker镜像无法拉取的问题</a><time datetime="2024-07-07T02:20:36.000Z" title="发表于 2024-07-07 10:20:36">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/50fa77229b05.html" title="docker-java使用win系统下docker">docker-java使用win系统下docker</a><time datetime="2024-07-07T02:18:45.000Z" title="发表于 2024-07-07 10:18:45">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/2d630400ad43.html" title="api开发平台">api开发平台</a><time datetime="2024-07-07T02:16:44.000Z" title="发表于 2024-07-07 10:16:44">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/e0edd63ff2be.html" title="python程序打包为win/linux可执行文件">python程序打包为win/linux可执行文件</a><time datetime="2024-07-07T01:47:49.000Z" title="发表于 2024-07-07 09:47:49">2024-07-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 阿库娅</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div style="width:300px;margin:0 auto"> <a href="https://beian.miit.gov.cn/" target="_blank">鲁ICP备2022041346号</a> <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=37148202000461"> <p> <img src="https://wordpress-img.upyun.ctcnb.cn/2023/01/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />鲁公网安备 37148202000461号</p> </a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>